<html lang="en"><head>
    <title>Project Futures Exchange Shanghai Page</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/d3-path.v2.min.js"></script>
    <script src="https://d3js.org/d3-shape.v2.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <script src="https://d3js.org/d3-array.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v3.min.js"></script>
    <script src="https://unpkg.com/react/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone/babel.js"></script>
    <link rel="stylesheet" href="styles.css"> 
<script>'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var margin = { top: 20, right: 30, bottom: 180, left: 80, gap: 50 };
var csvUrl = 'https://raw.githubusercontent.com/jjl720/capstone/main/exchange_level_data.csv';

function useData(csvPath) {
var _React$useState = React.useState(null),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    dataAll = _React$useState2[0],
    setData = _React$useState2[1];

React.useEffect(function () {
    d3.csv(csvPath).then(function (data) {
        data.forEach(function (d) {
            d.sharpe = +d.Sharpe;
            d.low = +d.low;
            d.mean = +d.mean;
            d.max = +d.max;
            d.mv = +d.volume;
            d.tv = +d.tradingvolume;
        });
        setData(data);
    });
}, []);
return dataAll;
}

function YAxis(props) {
var sys = props.sys,
    height = props.height,
    type = props.type;

var ticks = sys.ticks(10);
var judge = type == 'scatter';
var judge2 = type == 'bar2';
var judge3 = type == 'price';
var color1 = function color1(d) {
    return d > 2 ? 'red' : 'rgb(28, 231, 197)';
};
if (judge) {
    return React.createElement(
        'g',
        null,
        React.createElement('line', { y2: height, stroke: 'white' }),
        React.createElement('line', { x1: -600, y1: -50, x2: 500, y2: -50, stroke: 'purple' }),
        React.createElement(
            'text',
            { style: { font: 'sans-serif', fontSize: '14px' },
                transform: 'translate(5, -15)', y: 20, fill: 'white' },
            'Sharpe Ratio (yearly)'
        ),
        ticks.map(function (tickValue) {
            return React.createElement(
                'g',
                { key: tickValue, transform: 'translate(-10, ' + sys(tickValue) + ')' },
                React.createElement('line', { x2: 10, stroke: "white" }),
                React.createElement(
                    'text',
                    { style: { textAnchor: 'end', fontSize: '12px' }, fill: color1(tickValue) },
                    tickValue
                )
            );
        })
    );
}
if (judge2) {

    return React.createElement(
        'g',
        { transform: 'translate(470, 0)' },
        React.createElement('line', { y2: height, stroke: 'white' }),
        React.createElement(
            'text',
            { style: { font: 'sans-serif', textAnchor: 'middle', fontSize: '16px' }, fill: 'white', x: -770, y: -380 },
            'Yearly Overview'
        ),
        React.createElement(
            'text',
            { style: { font: 'sans-serif', textAnchor: 'middle', fontSize: '16px' }, fill: 'white', x: -180, y: -380 },
            'Monthly Details'
        ),
        React.createElement(
            'text',
            { style: { font: 'sans-serif', fontSize: '14px' },
                transform: 'translate(-150, -15)', y: 20, fill: 'white' },
            'trading volume (1e3)'
        ),
        ticks.map(function (tickValue) {
            return React.createElement(
                'g',
                { key: tickValue, transform: 'translate(0, ' + sys(tickValue) + ')' },
                React.createElement('line', { x2: 10, stroke: "white" }),
                React.createElement(
                    'text',
                    { style: { textAnchor: 'end', fontSize: '12px' }, transform: 'translate(32, 0)', fill: 'white' },
                    tickValue
                )
            );
        })
    );
}
if (judge3) {
    return React.createElement(
        'g',
        null,
        React.createElement('line', { y2: height, stroke: 'white' }),
        React.createElement(
            'text',
            { style: { font: 'sans-serif', fontSize: '14px' },
                transform: 'translate(5, -15)', y: 20, fill: 'white' },
            'Price Curve'
        ),
        ticks.map(function (tickValue) {
            return React.createElement(
                'g',
                { key: tickValue, transform: 'translate(-10, ' + sys(tickValue) + ')' },
                React.createElement('line', { x2: 10, stroke: "white" }),
                React.createElement(
                    'text',
                    { style: { textAnchor: 'end', fontSize: '12px' }, fill: 'white' },
                    tickValue
                )
            );
        })
    );
} else {
    return React.createElement(
        'g',
        null,
        React.createElement('line', { y2: height, stroke: 'white' }),
        React.createElement(
            'text',
            { style: { font: 'sans-serif', fontSize: '14px' }, fill: 'white',
                transform: 'translate(5, -15)', y: 20 },
            'market volume (1e5)'
        ),
        ticks.map(function (tickValue) {
            return React.createElement(
                'g',
                { key: tickValue, transform: 'translate(-10, ' + sys(tickValue) + ')' },
                React.createElement('line', { x2: 10, stroke: "white" }),
                React.createElement(
                    'text',
                    { style: { textAnchor: 'end', fontSize: '12px' }, fill: 'white' },
                    tickValue
                )
            );
        })
    );
}
}

function XAxis(props) {
var data = props.data,
    sxs = props.sxs,
    width = props.width,
    height = props.height,
    type = props.type;

var judge = type == 'scatter';
var judge2 = type == 'price';
if (judge) {
    var ticks = sxs.ticks(10);
    return React.createElement(
        'g',
        null,
        React.createElement('line', { y1: height, x2: width, y2: height, stroke: "white" }),
        React.createElement(
            'text',
            { style: { font: 'sans-serif', fontSize: '14px' },
                transform: 'translate(360, 270)', y: 20, fill: 'white' },
            'Trading Volume (1e3)'
        ),
        ticks.map(function (tickValue) {
            return React.createElement(
                'g',
                { key: tickValue, transform: 'translate(' + sxs(tickValue) + ', ' + height + ')' },
                React.createElement('line', { y2: 5, stroke: "white" }),
                React.createElement(
                    'text',
                    { style: { textAnchor: 'middle', fontSize: '12px', color: 'white' }, fill: 'white', y: 20 },
                    tickValue
                )
            );
        })
    );
}
if (judge2) {
    return React.createElement(
        'g',
        null,
        React.createElement('line', { y1: height, x2: width, y2: height, stroke: "white" }),
        data.map(function (d) {
            return React.createElement(
                'text',
                { style: { font: 'sans-serif', fontSize: '12px' }, fill: 'white',
                    transform: 'translate(' + sxs(d.month) + ', 293)', y: 20 },
                d.month
            );
        })
    );
} else {
    return React.createElement(
        'g',
        null,
        React.createElement('line', { y1: height, x2: width, y2: height, stroke: "white" }),
        data.map(function (d) {
            return React.createElement(
                'text',
                { style: { font: 'sans-serif', fontSize: '12px' }, fill: 'white',
                    transform: 'translate(' + sxs(d.Product) + ', 293)', y: 20 },
                d.Product
            );
        })
    );
}
}

function Points(props) {
console.log(props.selected);
var data = props.data,
    sxs = props.sxs,
    sys = props.sys;

console.log(1);
console.log(data);

// console.log(data.filter(function(d){return d.month == 'May' & d.Product == 'York St'}))
// function onMouseEnter(d){
//     props.setselected(d)
// }
// function onMouseOut(){
//     props.se
// }

var mouseOver = function mouseOver(d) {
    props.setselected(d.Product);
    props.settop(sys(d.sharpe));
    props.setleft(sxs(d.tv / 1000));
    props.setdata1(d.sharpe);
    props.setdata2(d.tv);
};
var mouseOut = function mouseOut() {
    props.setselected(null);
    props.settop(null);
};

var color = function color(d) {
    return d.tv === 0 ? "yellow" : d.Product === props.selected ? "steelblue" : d.sharpe > 2 ? 'red' : 'green';
};
var radius = function radius(d) {
    return d.Product === props.selected ? 7 : 5;
};
var opa = function opa(d) {
    return d === null ? 0 : 0.8;
};
var opa2 = function opa2(d) {
    return d === null ? 0 : 0.8;
};

var selecteddata = data.filter(function (d) {
    return d.Product === props.selected;
});
console.log('works?');
console.log(selecteddata[0]);
if (selecteddata[0]) {
    props.settop(sys(selecteddata[0].sharpe) - 50);
    props.setleft(sxs(selecteddata[0].tv / 1000) + 20);
}

return React.createElement(
    'g',
    null,
    data.map(function (d) {
        return React.createElement('circle', { key: d.Product,
            cx: sxs(d.tv / 1000),
            cy: sys(d.sharpe),
            r: radius(d),
            fill: color(d),
            stroke: 'white',
            onMouseOver: function onMouseOver() {
                mouseOver(d);
            },
            style: { transition: "1s" }
        });
    }),
    data.filter(function (d) {
        return d.Product == props.selected;
    }).map(function (d) {
        return React.createElement('circle', { key: d.Product,
            cx: sxs(d.tv / 1000),
            cy: sys(d.sharpe),
            r: radius(d),
            fill: color(d),
            stroke: 'white',
            onMouseOut: mouseOut,
            style: { transition: "100s" }
        });
    }),
    React.createElement('rect', { x: props.left, y: props.top, opacity: opa(props.selected),
        width: 180, height: 90, fill: 'lightblue' }),
    React.createElement(
        'text',
        { style: { font: 'sans-serif', fontSize: '12px' },
            transform: 'translate(' + props.left + ', ' + props.top + ')', x: 5, y: 30,
            opacity: opa2(props.selected) },
        props.selected
    ),
    React.createElement(
        'text',
        { style: { font: 'sans-serif', fontSize: '12px' },
            transform: 'translate(' + props.left + ', ' + props.top + ')', x: 25, y: 50,
            opacity: opa2(props.selected) },
        "Â· Trading Volume: ",
        Math.round(props.data2)
    ),
    React.createElement(
        'text',
        { style: { font: 'sans-serif', fontSize: '12px' },
            transform: 'translate(' + props.left + ', ' + props.top + ')', x: 25, y: 70,
            opacity: opa2(props.selected) },
        "Â· Sharpe Ratio: ",
        Math.floor(props.data1 * 100) / 100
    )
);
}

function OverPoints(props) {
console.log(props.selected);
var data = props.data,
    sxs = props.sxs,
    sys = props.sys;

console.log(1);
console.log(data);

// console.log(data.filter(function(d){return d.month == 'May' & d.Product == 'York St'}))
// function onMouseEnter(d){
//     props.setselected(d)
// }
// function onMouseOut(){
//     props.se
// }

var mouseOver = function mouseOver(d) {
    props.setselected(d.Product);
    props.settop(sys(d.maxi));
    props.setleft(sxs(d.Product));
    props.setdata1(d.sharpe);
    props.setdata2(d.tv);
};
var mouseOut = function mouseOut() {
    props.setselected(null);
    props.settop(null);
};

var color = function color(d) {
    return d.tv === 0 ? "yellow" : d.Product === props.selected ? "steelblue" : d.sharpe > 2 ? 'red' : 'green';
};
var radius = function radius(d) {
    return d.Product === props.selected ? 10 : 5;
};
var opa = function opa(d) {
    return d === null ? 0 : 0.8;
};
var opa2 = function opa2(d) {
    return d === null ? 0 : 0.8;
};

var selecteddata = data.filter(function (d) {
    return d.Product === props.selected;
});
console.log('works?');
console.log(selecteddata[0]);
if (selecteddata[0]) {
    props.settop(sys(selecteddata[0].maxi) - 50);
    props.setleft(sxs(selecteddata[0].Product) + 20);
}

var sharp = function sharp(d) {
    return d ? d.sharpe : 0;
};
var maxi = function maxi(d) {
    return d ? d.maxi : 0;
};
var mini = function mini(d) {
    return d ? d.mini : 0;
};

return React.createElement(
    'g',
    null,
    data.map(function (d) {
        return React.createElement('circle', { key: d.Product,
            cx: sxs(d.Product),
            cy: sys(d.sharpe),
            r: radius(d),
            fill: color(d),
            stroke: 'white',
            onMouseOver: function onMouseOver() {
                mouseOver(d);
            },
            style: { transition: "1s" }
        });
    }),
    data.filter(function (d) {
        return d.Product == props.selected;
    }).map(function (d) {
        return React.createElement('circle', { key: d.Product,
            cx: sxs(d.Product),
            cy: sys(d.sharpe),
            r: radius(d),
            fill: color(d),
            stroke: 'white',
            onMouseOut: mouseOut,
            style: { transition: "100s" }
        });
    }),
    data.filter(function (d) {
        return d.Product == props.selected;
    }).map(function (d) {
        return React.createElement('circle', { key: d.Product,
            cx: sxs(d.Product),
            cy: sys(d.mini),
            r: radius(d),
            fill: color(d),
            stroke: 'white',
            onMouseOut: mouseOut,
            style: { transition: "100s" }
        });
    }),
    data.filter(function (d) {
        return d.Product == props.selected;
    }).map(function (d) {
        return React.createElement('circle', { key: d.Product,
            cx: sxs(d.Product),
            cy: sys(d.maxi),
            r: radius(d),
            fill: color(d),
            stroke: 'white',
            onMouseOut: mouseOut,
            style: { transition: "100s" }
        });
    }),
    React.createElement('rect', { x: props.left, y: props.top, opacity: opa(props.selected),
        width: 180, height: 110, fill: 'lightblue' }),
    React.createElement(
        'text',
        { style: { font: 'sans-serif', fontSize: '12px' },
            transform: 'translate(' + props.left + ', ' + props.top + ')', x: 5, y: 30,
            opacity: opa2(props.selected) },
        props.selected
    ),
    React.createElement(
        'text',
        { style: { font: 'sans-serif', fontSize: '12px' },
            transform: 'translate(' + props.left + ', ' + props.top + ')', x: 25, y: 50,
            opacity: opa2(props.selected) },
        "Â· Max Sharpe Ratio: ",
        Math.floor(maxi(selecteddata[0]) * 100) / 100
    ),
    React.createElement(
        'text',
        { style: { font: 'sans-serif', fontSize: '12px' },
            transform: 'translate(' + props.left + ', ' + props.top + ')', x: 25, y: 70,
            opacity: opa2(props.selected) },
        "Â· Min Sharpe Ratio: ",
        Math.floor(mini(selecteddata[0]) * 100) / 100
    ),
    React.createElement(
        'text',
        { style: { font: 'sans-serif', fontSize: '12px' },
            transform: 'translate(' + props.left + ', ' + props.top + ')', x: 25, y: 90,
            opacity: opa2(props.selected) },
        "Â· Avg Sharpe Ratio: ",
        Math.floor(sharp(selecteddata[0]) * 100) / 100
    )
);
}

function ScatterPlot(props) {
var data = props.data;
if (!data) {
    return React.createElement(
        'pre',
        null,
        'Loading...'
    );
};
var WIDTH = 600;
var HEIGHT = 800;
var height = (HEIGHT - margin.top - margin.bottom) / 2;
var width = WIDTH - margin.left - margin.right - 20;
var sxs = d3.scaleLinear().range([0, width]).domain([0, d3.max(data, function (d) {
    return d.tv / 1000;
})]).nice();
console.log(d3.max(data, function (d) {
    return d.sharpe;
}));
var sys = d3.scaleLinear().range([height, 0]).domain([0, d3.max(data, function (d) {
    return d.sharpe;
})]).nice();

return React.createElement(
    'g',
    { transform: 'translate(' + (margin.left + 550 + props.addmore) + ', ' + (margin.top + 50) + ')' },
    React.createElement(Points, { data: props.data, sxs: sxs, sys: sys, color: 'steelblue',
        selected: props.selected, setselected: props.setselected,
        month: props.month,
        top: props.top, settop: props.settop,
        left: props.left, setleft: props.setleft,
        data1: props.data1, setdata1: props.setdata1,
        data2: props.data2, setdata2: props.setdata2,
        data3: props.data3, setdata3: props.setdata3 }),
    React.createElement(YAxis, { sys: sys, width: width, height: height, type: 'scatter' }),
    React.createElement(XAxis, { sxs: sxs, width: width, height: height, type: 'scatter' })
);
}

function OverScatterPlot(props) {
var data = props.data;
if (!data) {
    return React.createElement(
        'pre',
        null,
        'Loading...'
    );
};
var WIDTH = 600;
var HEIGHT = 800;
var height = (HEIGHT - margin.top - margin.bottom) / 2;
var width = WIDTH - margin.left - margin.right - 20;
var sxs = d3.scaleBand().range([0, width]).domain(data.map(function (d) {
    return d.Product;
}));
var sys = d3.scaleLinear().range([height, 0]).domain([0, d3.max(data, function (d) {
    return d.maxi;
})]).nice();
console.log('whats wrong');
console.log(data);

return React.createElement(
    'g',
    { transform: 'translate(' + (margin.left + 550 + props.addmore) + ', ' + (margin.top + 50) + ')' },
    React.createElement(OverPoints, { data: props.data, sxs: sxs, sys: sys, color: 'steelblue',
        selected: props.selected, setselected: props.setselected,
        month: props.month,
        top: props.top1, settop: props.settop1,
        left: props.left1, setleft: props.setleft1,
        data1: props.data1, setdata1: props.setdata1,
        data2: props.data2, setdata2: props.setdata2,
        data3: props.data3, setdata3: props.setdata3 }),
    React.createElement(YAxis, { sys: sys, width: width, height: height, type: 'scatter' }),
    React.createElement(XAxis, { data: props.data, sxs: sxs, width: width, height: height, type: 'bar' })
);
}

function Bars(props) {
var _React$useState3 = React.useState(null),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    selected = _React$useState4[0],
    setselected = _React$useState4[1];

var data = props.data,
    sxs = props.sxs,
    sys = props.sys,
    bxs = props.bxs,
    bys = props.bys,
    by2 = props.by2;

// function onMouseEnter(d){
//     props.setselected(d)
// }
// function onMouseOut(){
//     props.se
// }

var mouseOver = function mouseOver(d) {
    props.setselected(d.Product);
    props.settop(sys(d.sharpe));
    props.setleft(sxs(d.tv / 1000));
    props.setdata1(d.sharpe);
    props.setdata2(d.tv);
};
var mouseOut = function mouseOut() {
    props.setselected(null);
    props.settop(null);
};

var color = function color(d) {
    return d.Product === props.selected ? "steelblue" : "yellow";
};
var color2 = function color2(d) {
    return d.Product === props.selected ? "steelblue" : d.mv / maxmv * 100 > d.tv / maxtv * 100 ? "green" : "red";
};

var maxtv = d3.max(data, function (d) {
    return d.tv;
});
var maxmv = d3.max(data, function (d) {
    return d.mv;
});
return React.createElement(
    'g',
    null,
    data.map(function (d) {
        return React.createElement('rect', { key: d.Product, x: bxs(d.Product), y: bys(d.mv / maxmv * 100),
            width: 10, height: 300 - bys(d.mv / maxmv * 100),
            fill: color(d), stroke: 'white',
            onMouseOver: function onMouseOver() {
                mouseOver(d);
            },
            onMouseOut: mouseOut });
    }),
    data.map(function (d) {
        return React.createElement('rect', { key: d.Product, x: bxs(d.Product) + 10, y: by2(d.tv / maxtv * 100),
            width: 10, height: 300 - by2(d.tv / maxtv * 100),
            fill: color2(d), stroke: 'white',
            onMouseOver: function onMouseOver() {
                mouseOver(d);
            },
            onMouseOut: mouseOut });
    })
);
}

function BarChart(props) {
var data = props.data;
if (!data) {
    return React.createElement(
        'pre',
        null,
        'Loading...'
    );
};
var WIDTH = 600;
var HEIGHT = 800;
var height = (HEIGHT - margin.top - margin.bottom) / 2;
var width = WIDTH - margin.left - margin.right - 20;
var sxs = d3.scaleLinear().range([0, width]).domain([0, d3.max(data, function (d) {
    return d.tv / 1000;
})]).nice();
var sys = d3.scaleLinear().range([height, 0]).domain([0, d3.max(data, function (d) {
    return d.sharpe;
})]).nice();
var bxs = d3.scaleBand().range([0, width]).domain(data.map(function (d) {
    return d.Product;
}));
var bys = d3.scaleLinear().range([height, 0]).domain([0, 100]).nice();
var by2 = d3.scaleLinear().range([height, 0]).domain([0, 100]).nice();

return React.createElement(
    'g',
    { transform: 'translate(' + (margin.left + 550) + ', ' + (margin.top + height + 100) + ')' },
    React.createElement(Bars, { data: props.data, sxs: sxs, sys: sys, bxs: bxs, bys: bys, by2: by2,
        selected: props.selected, setselected: props.setselected,
        top: props.top, settop: props.settop,
        left: props.left, setleft: props.setleft,
        data1: props.data1, setdata1: props.setdata1,
        data2: props.data2, setdata2: props.setdata2,
        data3: props.data3, setdata3: props.setdata3,
        month: props.month }),
    React.createElement(YAxis, { sys: bys, width: width, height: height, type: 'bar' }),
    React.createElement(YAxis, { sys: by2, width: width, height: height, type: 'bar2' }),
    React.createElement(XAxis, { data: props.data, sxs: bxs, width: width, height: height, type: 'bar' })
);
}

function SymmetricAreaChart(props) {
var offsetX = props.offsetX,
    offsetY = props.offsetY,
    data = props.data,
    height = props.height,
    width = props.width;
//the text needed is given in the following

var xScale = d3.scaleBand().domain(['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12']).range([0, width]);

var yScale = d3.scaleLinear().domain([0, d3.max([d3.max(data, function (d) {
    return d.low;
}), d3.max(data, function (d) {
    return d.max;
})])]).range([height / 2, 0]).nice();
var p1 = d3.area().x(function (d) {
    return xScale(d.month);
}).y0(height / 2).y1(function (d) {
    return yScale(d.low);
}).curve(d3.curveBasis)(data);

var p2 = d3.area().x(function (d) {
    return xScale(d.month);
}).y0(height / 2).y1(function (d) {
    return yScale(-d.max);
}).curve(d3.curveBasis)(data);

var p3 = d3.area().x(function (d) {
    return xScale(d.month);
}).y0(height / 2).y1(function (d) {
    return yScale(d.mean);
}).curve(d3.curveBasis)(data);

console.log('symm');
console.log(data);

return React.createElement(
    'g',
    { transform: 'translate(' + 600 + ', ' + 0 + ')' },
    React.createElement('path', { d: p1, fill: 'lightgreen', stroke: 'white' }),
    React.createElement('path', { d: p3, fill: 'blue', stroke: 'white' }),
    React.createElement('path', { d: p2, fill: 'red', stroke: 'white' }),
    React.createElement('line', { y2: height, stroke: 'white', transform: 'translate(0, 0)' }),
    xScale.domain().map(function (tickValue) {
        return React.createElement(
            'g',
            { key: tickValue + 'B', transform: 'translate(' + (xScale(tickValue) - 10) + ', 30)' },
            React.createElement('line', { y2: 10, transform: 'translate(10, ' + (height - 22) + ')', stroke: 'white' }),
            React.createElement(
                'text',
                { style: { textAnchor: 'start', fontSize: '12px' }, y: height,
                    transform: 'rotate(0, 0, ' + (height + 3) + ')' },
                ' ',
                tickValue
            )
        );
    }),
    yScale.ticks(2).map(function (tickValue) {
        return React.createElement(
            'g',
            { key: tickValue, transform: 'translate(-10, ' + yScale(tickValue) + ')' },
            React.createElement('line', { x2: 10, stroke: 'white' }),
            React.createElement(
                'text',
                { style: { textAnchor: 'end', fontSize: '10px' } },
                tickValue
            )
        );
    }),
    yScale.ticks(2).reverse().map(function (tickValue) {
        return React.createElement(
            'g',
            { key: tickValue, transform: 'translate(-10, ' + (height - yScale(tickValue)) + ')' },
            React.createElement('line', { x2: 10, stroke: 'white' }),
            React.createElement(
                'text',
                { style: { textAnchor: 'end', fontSize: '10px' } },
                tickValue
            )
        );
    }),
    React.createElement('line', { x1: 600, y1: height / 2, x2: 1000, y2: height / 2, stroke: 'white' }),
    React.createElement(
        'text',
        { style: { textAnchor: 'end', fontSize: '15px' }, transform: 'translate(' + width + ', ' + 20 + ')rotate(0)' },
        "Start"
    ),
    React.createElement(
        'text',
        { style: { textAnchor: 'end', fontSize: '15px' }, transform: 'translate(' + width * 2 / 3 + ', ' + -10 + ')rotate(0)' },
        "Num. of riders over the year"
    ),
    React.createElement(
        'g',
        { transform: 'translate(' + offsetX + ', ' + (offsetY + height / 2) + ')' },
        React.createElement(
            'text',
            { style: { textAnchor: 'end', fontSize: '15px' }, transform: 'translate(' + width + ', ' + (height / 2 - 20) + ')rotate(0)' },
            "End"
        )
    )
);
}

function Pathdraw(props) {
console.log(props.selected);
var data = props.data,
    sxs = props.sxs,
    sys = props.sys;

console.log('really????');
console.log(sxs('02'));

// console.log(data.filter(function(d){return d.month == 'May' & d.Product == 'York St'}))
// function onMouseEnter(d){
//     props.setselected(d)
// }
// function onMouseOut(){
//     props.se
// }

var mouseOver = function mouseOver(d) {
    props.setselected(d.Product);
    props.settop(sys(d.sharpe));
    props.setleft(sxs(d.tv / 1000));
    props.setdata1(d.sharpe);
    props.setdata2(d.tv);
};
var mouseOut = function mouseOut() {
    props.setselected(null);
    props.settop(null);
};

var color = function color(d) {
    return d.month === props.currentmonth ? 'steelblue' : 'black';
};
var radius = function radius(d) {
    return d.month === props.currentmonth ? 5 : 3;
};
var opa = function opa(d) {
    return d === null ? 0 : 0.6;
};
var opa2 = function opa2(d) {
    return d === null ? 0 : 0.8;
};

var p1 = d3.area().x(function (d) {
    return sxs(d.month) + 10;
}).y0(300).y1(function (d) {
    return sys(d.max);
}).curve(d3.curveBasis)(data);

var p2 = d3.area().x(function (d) {
    return sxs(d.month) + 10;
}).y0(300).y1(function (d) {
    return sys(d.low);
}).curve(d3.curveBasis)(data);

var p3 = d3.area().x(function (d) {
    return sxs(d.month) + 10;
}).y0(300).y1(function (d) {
    return sys(d.mean);
}).curve(d3.curveBasis)(data);

return React.createElement(
    'g',
    null,
    React.createElement('path', { d: p1, fill: 'red', stroke: 'white' }),
    React.createElement('path', { d: p3, fill: 'lightgreen', stroke: 'white' }),
    React.createElement('path', { d: p2, fill: 'black', stroke: 'white' }),
    data.map(function (d) {
        return React.createElement('circle', { cx: sxs(d.month) + 10,
            cy: sys(d.mean),
            r: radius(d),
            fill: color(d),
            stroke: 'white',
            onMouseOver: function onMouseOver() {
                mouseOver(d);
            },
            style: { transition: "1s" }
        });
    })
);
}

function PriceCurve(props) {
var data = props.data;
if (!data) {
    return React.createElement(
        'pre',
        null,
        'Loading...'
    );
};
var WIDTH = 600;
var HEIGHT = 800;
var height = (HEIGHT - margin.top - margin.bottom) / 2;
var width = WIDTH - margin.left - margin.right - 20;
var sxs = d3.scaleBand().range([0, width]).domain(data.map(function (d) {
    return d.month;
}));
console.log('pricepriceprice');
console.log(d3.max(data, function (d) {
    return d.sharpe;
}));
var sys = d3.scaleLinear().range([height, 0]).domain([0, d3.max(data, function (d) {
    return d.max;
})]).nice();

if (props.selected == null) {
    console.log('no more');
    return React.createElement('div', null);
} else {
    return React.createElement(
        'g',
        { transform: 'translate(' + (margin.left + 20) + ', ' + (margin.top + height + 100) + ')' },
        React.createElement(Pathdraw, { data: props.data, sxs: sxs, sys: sys, color: 'steelblue',
            selected: props.selected, setselected: props.setselected,
            month: props.month,
            top: props.top, settop: props.settop,
            left: props.left, setleft: props.setleft,
            data1: props.data1, setdata1: props.setdata1,
            data2: props.data2, setdata2: props.setdata2,
            data3: props.data3, setdata3: props.setdata3,
            currentmonth: props.currentmonth }),
        React.createElement(YAxis, { sys: sys, width: width, height: height, type: 'price' }),
        React.createElement(XAxis, { data: props.data, sxs: sxs, width: width, height: height, type: 'price' })
    );
}
}

function Tooltip(props) {
var d = props.d,
    stationYearData = props.stationYearData,
    left = props.left,
    top = props.top,
    height = props.height,
    width = props.width;

if (props.d == null) {
    console.log('no more');
    return React.createElement('div', null);
} else {
    console.log(stationYearData);
    console.log(d);
    console.log('here');
    return React.createElement(
        'g',
        { transform: 'translate(' + left + ', ' + top + ')' },
        React.createElement(
            'text',
            { style: { textAnchor: 'start', fontSize: '15px' }, transform: 'translate(' + 0 + ', ' + -5 + ')rotate(0)' },
            d.Product,
            ' '
        ),
        React.createElement(PriceCurve, { data: stationYearData,
            addmore: 600 })
    );
}
}

var Charts = function Charts() {
var Home_page = function Home_page() {
    return React.createElement(
        'div',
        null,
        React.createElement(
            'a',
            { href: 'index.html', fill: 'white' },
            React.createElement(
                'button',
                { 'class': 'button' },
                React.createElement(
                    'text',
                    { style: { textAnchor: 'bottom', fontSize: '2em' }, fill: 'white', x: "0%", y: "0" },
                    'Information Vizualization Project - Shanghai'
                )
            )
        ),
        React.createElement(
            'svg',
            { width: '100%', height: '1' },
            React.createElement('line', { x2: '100%', y1: '100%', y2: '100%', stroke: 'white' })
        )
    );
};
var test = window.location.href;
console.log(test.split('=')[1].split('-')[1]);
var mn = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
var YEAR = ['2017', '2018', '2019', '2020'];

var _React$useState5 = React.useState(null),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    selected = _React$useState6[0],
    setselected = _React$useState6[1];

var _React$useState7 = React.useState(null),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    top = _React$useState8[0],
    settop = _React$useState8[1];

var _React$useState9 = React.useState(null),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    left = _React$useState10[0],
    setleft = _React$useState10[1];

var _React$useState11 = React.useState(null),
    _React$useState12 = _slicedToArray(_React$useState11, 2),
    top1 = _React$useState12[0],
    settop1 = _React$useState12[1];

var _React$useState13 = React.useState(null),
    _React$useState14 = _slicedToArray(_React$useState13, 2),
    left1 = _React$useState14[0],
    setleft1 = _React$useState14[1];

var _React$useState15 = React.useState(null),
    _React$useState16 = _slicedToArray(_React$useState15, 2),
    data1 = _React$useState16[0],
    setdata1 = _React$useState16[1];

var _React$useState17 = React.useState(null),
    _React$useState18 = _slicedToArray(_React$useState17, 2),
    data2 = _React$useState18[0],
    setdata2 = _React$useState18[1];

var _React$useState19 = React.useState(null),
    _React$useState20 = _slicedToArray(_React$useState19, 2),
    data3 = _React$useState20[0],
    setdata3 = _React$useState20[1];

var _React$useState21 = React.useState(4),
    _React$useState22 = _slicedToArray(_React$useState21, 2),
    value = _React$useState22[0],
    setvalue = _React$useState22[1];

var _React$useState23 = React.useState(mn.indexOf(test.split('=')[1].split('-')[1])),
    _React$useState24 = _slicedToArray(_React$useState23, 2),
    month = _React$useState24[0],
    setMonth = _React$useState24[1];

var _React$useState25 = React.useState(YEAR.indexOf(test.split('=')[1].split('-')[0])),
    _React$useState26 = _slicedToArray(_React$useState25, 2),
    year = _React$useState26[0],
    setYear = _React$useState26[1];

var monthlist = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var MONTH = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
// let slider = d3.select('#slider');
// let slidertext = d3.select('#slidertext')
// slider.on("input", function(){
//     console.log(1)
//     slidertext.attr('value', month[this.value-1]);
// });
var dataAll = useData(csvUrl);
if (!dataAll) {
    return React.createElement(
        'pre',
        null,
        'Loading...'
    );
};
var WIDTH = 2600;
var HEIGHT = 800;
var innerHeight = HEIGHT - margin.top - margin.bottom;
var innerWidth = WIDTH - margin.left - margin.right;

var data_year = dataAll.filter(function (d) {
    return d.year == YEAR[year] & d.Exchange == 'CZCE';
});

var data_final = data_year.filter(function (d) {
    var mn = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
    return d.month == mn[month];
});

var changeHandlerMonth = function changeHandlerMonth(event) {
    setMonth(event.target.value);
};
var changeHandlerYear = function changeHandlerYear(event) {
    setYear(event.target.value);
};

var selectedPoint = dataAll.filter(function (d) {
    return d.Product === selected;
})[0];

console.log(mn[month]);
console.log('another');

var stationYearData = data_year.filter(function (d) {
    return d.Product == selected;
});
var allprod = data_final.map(function (d) {
    return d.Product;
});
console.log('what');

console.log('try the average');
console.log(d3.mean(data_year.filter(function (d) {
    return d.Product === 'bu';
}), function (d) {
    return d.sharpe;
}));

var avgsharp = [];
allprod.forEach(function (k) {
    return avgsharp.push({ Product: k,
        sharpe: d3.mean(data_year.filter(function (d) {
            return d.Product === k;
        }), function (d) {
            return d.sharpe;
        }),
        maxi: d3.max(data_year.filter(function (d) {
            return d.Product === k;
        }), function (d) {
            return d.sharpe;
        }),
        mini: d3.min(data_year.filter(function (d) {
            return d.Product === k;
        }), function (d) {
            return d.sharpe;
        }) });
});
console.log(avgsharp);

return React.createElement(
    'div',
    null,
    React.createElement(
        'div',
        null,
        React.createElement(
            'div',
            { 'class': 'years', align: 'left' },
            React.createElement('input', { key: 'slider', type: 'range', 'class': 'slider', list: 'tickmarks', min: '0', max: '3', value: year, step: '1', onChange: changeHandlerYear }),
            React.createElement(
                'datalist',
                { id: 'tickmarks' },
                React.createElement('option', { value: '0' }),
                React.createElement('option', { value: '1' }),
                React.createElement('option', { value: '2' }),
                React.createElement('option', { value: '3' })
            ),
            React.createElement('input', { key: 'monthText', 'class': 'labelinput', type: 'text', value: YEAR[year], readOnly: true })
        )
    ),
    React.createElement(
        'div',
        { 'class': 'month', align: 'center' },
        React.createElement('input', { key: 'slider', type: 'range', list: 'tick', 'class': 'slider', min: '0', max: '11', value: month, step: '1', onChange: changeHandlerMonth }),
        React.createElement(
            'datalist',
            { id: 'tick' },
            React.createElement('option', { value: '0' }),
            React.createElement('option', { value: '1' }),
            React.createElement('option', { value: '2' }),
            React.createElement('option', { value: '3' }),
            React.createElement('option', { value: '4' }),
            React.createElement('option', { value: '5' }),
            React.createElement('option', { value: '6' }),
            React.createElement('option', { value: '7' }),
            React.createElement('option', { value: '8' }),
            React.createElement('option', { value: '9' }),
            React.createElement('option', { value: '10' }),
            React.createElement('option', { value: '11' }),
            React.createElement('option', { value: '12' })
        ),
        React.createElement('input', { key: 'monthText', 'class': 'labelinput', type: 'text', value: MONTH[month], readOnly: true })
    ),
    React.createElement(
        'svg',
        { width: WIDTH, height: HEIGHT },
        React.createElement(ScatterPlot, { selected: selected, setselected: setselected,
            top: top, settop: settop,
            left: left, setleft: setleft,
            data1: data1, setdata1: setdata1,
            data2: data2, setdata2: setdata2,
            data3: data3, setdata3: setdata3,
            data: data_final,
            addmore: 0 }),
        React.createElement(OverScatterPlot, { selected: selected, setselected: setselected,
            top1: top1, settop1: settop1,
            left1: left1, setleft1: setleft1,
            data1: data1, setdata1: setdata1,
            data2: data2, setdata2: setdata2,
            data3: data3, setdata3: setdata3,
            data: avgsharp, data_year: data_year,
            addmore: -530 }),
        React.createElement(BarChart, { selected: selected, setselected: setselected,
            top: top, settop: settop,
            left: left, setleft: setleft,
            data1: data1, setdata1: setdata1,
            data2: data2, setdata2: setdata2,
            data3: data3, setdata3: setdata3,
            data: data_final }),
        React.createElement(PriceCurve, { selected: selected, setselected: setselected,
            top: top, settop: settop,
            left: left, setleft: setleft,
            data1: data1, setdata1: setdata1,
            data2: data2, setdata2: setdata2,
            data3: data3, setdata3: setdata3,
            data: stationYearData, currentmonth: mn[month],
            addmore: 600 })
    ),
    React.createElement(
        'div',
        null,
        React.createElement(
            'a',
            { href: 'index.html', fill: 'white' },
            React.createElement(
                'button',
                { 'class': 'button' },
                React.createElement(
                    'text',
                    { style: { textAnchor: 'bottom', fontSize: '2em' }, fill: 'white', x: "0%", y: "0" },
                    'Home Page'
                )
            )
        ),
        React.createElement(
            'svg',
            { width: '100%', height: '1' },
            React.createElement('line', { x2: '100%', y1: '100%', y2: '100%', stroke: 'white' })
        )
    )
);
};
var rootElement = document.getElementById('root');

ReactDOM.render(React.createElement(Charts, null), document.getElementById('root'));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIklubGluZSBCYWJlbCBzY3JpcHQiXSwibmFtZXMiOlsibWFyZ2luIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiZ2FwIiwiY3N2VXJsIiwidXNlRGF0YSIsImNzdlBhdGgiLCJSZWFjdCIsInVzZVN0YXRlIiwiZGF0YUFsbCIsInNldERhdGEiLCJ1c2VFZmZlY3QiLCJkMyIsImNzdiIsInRoZW4iLCJkYXRhIiwiZm9yRWFjaCIsImQiLCJzaGFycGUiLCJTaGFycGUiLCJsb3ciLCJtZWFuIiwibWF4IiwibXYiLCJ2b2x1bWUiLCJ0diIsInRyYWRpbmd2b2x1bWUiLCJZQXhpcyIsInByb3BzIiwic3lzIiwiaGVpZ2h0IiwidHlwZSIsInRpY2tzIiwianVkZ2UiLCJqdWRnZTIiLCJqdWRnZTMiLCJjb2xvcjEiLCJmb250IiwiZm9udFNpemUiLCJtYXAiLCJ0aWNrVmFsdWUiLCJ0ZXh0QW5jaG9yIiwiWEF4aXMiLCJzeHMiLCJ3aWR0aCIsImNvbG9yIiwibW9udGgiLCJQcm9kdWN0IiwiUG9pbnRzIiwiY29uc29sZSIsImxvZyIsInNlbGVjdGVkIiwibW91c2VPdmVyIiwic2V0c2VsZWN0ZWQiLCJzZXR0b3AiLCJzZXRsZWZ0Iiwic2V0ZGF0YTEiLCJzZXRkYXRhMiIsIm1vdXNlT3V0IiwicmFkaXVzIiwib3BhIiwib3BhMiIsInNlbGVjdGVkZGF0YSIsImZpbHRlciIsInRyYW5zaXRpb24iLCJNYXRoIiwicm91bmQiLCJkYXRhMiIsImZsb29yIiwiZGF0YTEiLCJPdmVyUG9pbnRzIiwibWF4aSIsInNoYXJwIiwibWluaSIsIlNjYXR0ZXJQbG90IiwiV0lEVEgiLCJIRUlHSFQiLCJzY2FsZUxpbmVhciIsInJhbmdlIiwiZG9tYWluIiwibmljZSIsImFkZG1vcmUiLCJkYXRhMyIsInNldGRhdGEzIiwiT3ZlclNjYXR0ZXJQbG90Iiwic2NhbGVCYW5kIiwidG9wMSIsInNldHRvcDEiLCJsZWZ0MSIsInNldGxlZnQxIiwiQmFycyIsImJ4cyIsImJ5cyIsImJ5MiIsImNvbG9yMiIsIm1heG12IiwibWF4dHYiLCJCYXJDaGFydCIsIlN5bW1ldHJpY0FyZWFDaGFydCIsIm9mZnNldFgiLCJvZmZzZXRZIiwieFNjYWxlIiwieVNjYWxlIiwicDEiLCJhcmVhIiwieCIsInkwIiwieTEiLCJjdXJ2ZSIsImN1cnZlQmFzaXMiLCJwMiIsInAzIiwicmV2ZXJzZSIsIlBhdGhkcmF3IiwiY3VycmVudG1vbnRoIiwiUHJpY2VDdXJ2ZSIsIlRvb2x0aXAiLCJzdGF0aW9uWWVhckRhdGEiLCJDaGFydHMiLCJIb21lX3BhZ2UiLCJ0ZXN0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwic3BsaXQiLCJtbiIsIllFQVIiLCJ2YWx1ZSIsInNldHZhbHVlIiwiaW5kZXhPZiIsInNldE1vbnRoIiwieWVhciIsInNldFllYXIiLCJtb250aGxpc3QiLCJNT05USCIsImlubmVySGVpZ2h0IiwiaW5uZXJXaWR0aCIsImRhdGFfeWVhciIsIkV4Y2hhbmdlIiwiZGF0YV9maW5hbCIsImNoYW5nZUhhbmRsZXJNb250aCIsImV2ZW50IiwidGFyZ2V0IiwiY2hhbmdlSGFuZGxlclllYXIiLCJzZWxlY3RlZFBvaW50IiwiYWxscHJvZCIsImF2Z3NoYXJwIiwicHVzaCIsImsiLCJtaW4iLCJyb290RWxlbWVudCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJSZWFjdERPTSIsInJlbmRlciJdLCJtYXBwaW5ncyI6Ijs7OztBQUVZLElBQU1BLFNBQVMsRUFBRUMsS0FBSyxFQUFQLEVBQVdDLE9BQU8sRUFBbEIsRUFBc0JDLFFBQVEsR0FBOUIsRUFBbUNDLE1BQU0sRUFBekMsRUFBNkNDLEtBQUssRUFBbEQsRUFBZjtBQUNBLElBQU1DLFNBQVMsMElBQWY7O0FBRUEsU0FBU0MsT0FBVCxDQUFpQkMsT0FBakIsRUFBeUI7QUFBQSwwQkFDTUMsTUFBTUMsUUFBTixDQUFlLElBQWYsQ0FETjtBQUFBO0FBQUEsUUFDZEMsT0FEYztBQUFBLFFBQ0xDLE9BREs7O0FBRXJCSCxVQUFNSSxTQUFO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QU9nQix5QkFBUyxHQVB6QjtBQXhCSixTQWxDSjtBQW1FSTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUEsa0JBQUcsTUFBTyxZQUFWLEVBQXVCLE1BQU8sT0FBOUI7QUFDQTtBQUFBO0FBQUEsc0JBQVEsU0FBUSxRQUFoQjtBQUNJO0FBQUE7QUFBQSwwQkFBTSxPQUFPLEVBQUVMLFlBQVcsUUFBYixFQUF1QkgsVUFBUyxLQUFoQyxFQUFiLEVBQXFELE1BQU8sT0FBNUQsRUFBb0UsR0FBSyxJQUF6RSxFQUErRSxHQUFLLEdBQXBGO0FBQUE7QUFBQTtBQURKO0FBREEsYUFEQTtBQVFBO0FBQUE7QUFBQSxrQkFBSyxPQUFRLE1BQWIsRUFBb0IsUUFBUyxHQUE3QjtBQUNBLDhDQUFPLElBQUcsTUFBVixFQUFpQixJQUFHLE1BQXBCLEVBQTJCLElBQUcsTUFBOUIsRUFBcUMsUUFBUyxPQUE5QztBQURBO0FBUkE7QUFuRUosS0FESjtBQWtGSCxDQTFLRDtBQTJLQSxJQUFNZ0gsY0FBY0MsU0FBU0MsY0FBVCxDQUF3QixNQUF4QixDQUFwQjs7QUFFREMsU0FBU0MsTUFBVCxDQUFpQixvQkFBQyxNQUFELE9BQWpCLEVBQTZCSCxTQUFTQyxjQUFULENBQXdCLE1BQXhCLENBQTdCIiwiZmlsZSI6IklubGluZSBCYWJlbCBzY3JpcHQiLCJzb3VyY2VzQ29udGVudCI6WyJcblxuICAgICAgICAgICAgY29uc3QgbWFyZ2luID0geyB0b3A6IDIwLCByaWdodDogMzAsIGJvdHRvbTogMTgwLCBsZWZ0OiA4MCwgZ2FwOiA1MCB9O1xuICAgICAgICAgICAgY29uc3QgY3N2VXJsID0gJ2h0dHBzOi8vZ2lzdC5naXRodWJ1c2VyY29udGVudC5jb20vUGF0cmljay1DRC9jMjNjM2QxZDBiYTkxODY1NjRjYmRmNDRjZmJmNGNmOS9yYXcvNjk2N2ZkMGRjYTA1OTIyMzdiNzkwZjhiNWY3MzdkZmFmY2E0MmUyOS95bV9zaGFycC5jc3YnXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVzZURhdGEoY3N2UGF0aCl7XG4gICAgICAgICAgICAgICAgY29uc3QgW2RhdGFBbGwsIHNldERhdGFdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZDMuY3N2KGNzdlBhdGgpLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5zaGFycGUgPSArZC5TaGFycGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5sb3cgPSArZC5sb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5tZWFuID0gK2QubWVhbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLm1heCA9ICtkLm1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLm12ID0gK2Qudm9sdW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQudHYgPSArZC50cmFkaW5ndm9sdW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFBbGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFlBeGlzKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge3N5cywgaGVpZ2h0LCB0eXBlfSA9IHByb3BzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tzID0gc3lzLnRpY2tzKDEwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBqdWRnZSA9IHR5cGUgPT0gJ3NjYXR0ZXInO1xuICAgICAgICAgICAgICAgIGNvbnN0IGp1ZGdlMiA9IHR5cGUgPT0gJ2JhcjInO1xuICAgICAgICAgICAgICAgIGNvbnN0IGp1ZGdlMyA9IHR5cGUgPT0gJ3ByaWNlJztcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvcjEgPSBkID0+IGQgPiAyID8gJ3JlZCcgOiAncmdiKDI4LCAyMzEsIDE5NyknO1xuICAgICAgICAgICAgICAgIGlmIChqdWRnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGluZSB5Mj17aGVpZ2h0fSBzdHJva2UgPXtgd2hpdGVgfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmUgeDE9ey02MDB9IHkxID0gey01MH0geDI9IHs1MDB9IHkyPXstNTB9IHN0cm9rZSA9e2BwdXJwbGVgfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgZm9udDogJ3NhbnMtc2VyaWYnLCBmb250U2l6ZTogJzE0cHgnfX0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoNSwgLTE1KWB9IHk9ezIwfSBmaWxsPXsnd2hpdGUnfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsnU2hhcnBlIFJhdGlvICh5ZWFybHkpJ30gXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICB7dGlja3MubWFwKCB0aWNrVmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZyBrZXk9e3RpY2tWYWx1ZX0gdHJhbnNmb3JtPXtgdHJhbnNsYXRlKC0xMCwgJHtzeXModGlja1ZhbHVlKX0pYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGluZSB4Mj17MTB9IHN0cm9rZT17XCJ3aGl0ZVwifSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgdGV4dEFuY2hvcjonZW5kJywgZm9udFNpemU6JzEycHgnfX0gZmlsbD17Y29sb3IxKHRpY2tWYWx1ZSl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RpY2tWYWx1ZX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZz4gfSl9XG4gICAgICAgICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGp1ZGdlMikge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxnICB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoNDcwLCAwKWB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmUgeTI9e2hlaWdodH0gc3Ryb2tlID17YHdoaXRlYH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHN0eWxlPXt7IGZvbnQ6ICdzYW5zLXNlcmlmJywgdGV4dEFuY2hvcjonbWlkZGxlJywgZm9udFNpemU6JzE2cHgnfX0gZmlsbD17J3doaXRlJ30geCA9IHstNzcwfSB5PXstMzgwfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFllYXJseSBPdmVydmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgZm9udDogJ3NhbnMtc2VyaWYnLCB0ZXh0QW5jaG9yOidtaWRkbGUnLCBmb250U2l6ZTonMTZweCd9fSBmaWxsPXsnd2hpdGUnfSB4ID0gey0xODB9IHk9ey0zODB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9udGhseSBEZXRhaWxzXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGV4dCBzdHlsZT17eyBmb250OiAnc2Fucy1zZXJpZicsIGZvbnRTaXplOiAnMTRweCd9fSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKC0xNTAsIC0xNSlgfSB5PXsyMH0gZmlsbD17J3doaXRlJ30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J3RyYWRpbmcgdm9sdW1lICgxZTMpJ30gXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICB7dGlja3MubWFwKCB0aWNrVmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZyBrZXk9e3RpY2tWYWx1ZX0gdHJhbnNmb3JtPXtgdHJhbnNsYXRlKDAsICR7c3lzKHRpY2tWYWx1ZSl9KWB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmUgeDI9ezEwfSBzdHJva2U9e1wid2hpdGVcIn0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHN0eWxlPXt7IHRleHRBbmNob3I6J2VuZCcsIGZvbnRTaXplOicxMnB4J319IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgzMiwgMClgfSBmaWxsPXsnd2hpdGUnfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aWNrVmFsdWV9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+IH0pfVxuICAgICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqdWRnZTMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmUgeTI9e2hlaWdodH0gc3Ryb2tlID17YHdoaXRlYH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHN0eWxlPXt7IGZvbnQ6ICdzYW5zLXNlcmlmJywgZm9udFNpemU6ICcxNHB4J319ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKDUsIC0xNSlgfSB5PXsyMH0gZmlsbD17J3doaXRlJ30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J1ByaWNlIEN1cnZlJ30gXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICB7dGlja3MubWFwKCB0aWNrVmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZyBrZXk9e3RpY2tWYWx1ZX0gdHJhbnNmb3JtPXtgdHJhbnNsYXRlKC0xMCwgJHtzeXModGlja1ZhbHVlKX0pYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGluZSB4Mj17MTB9IHN0cm9rZT17XCJ3aGl0ZVwifSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgdGV4dEFuY2hvcjonZW5kJywgZm9udFNpemU6JzEycHgnfX0gZmlsbD17J3doaXRlJ30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGlja1ZhbHVlfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPiB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmUgeTI9e2hlaWdodH0gc3Ryb2tlID17YHdoaXRlYH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHN0eWxlPXt7IGZvbnQ6ICdzYW5zLXNlcmlmJywgZm9udFNpemU6ICcxNHB4J30gfSAgZmlsbD17J3doaXRlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKDUsIC0xNSlgfSB5PXsyMH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J21hcmtldCB2b2x1bWUgKDFlNSknfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt0aWNrcy5tYXAoIHRpY2tWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxnIGtleT17dGlja1ZhbHVlfSB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoLTEwLCAke3N5cyh0aWNrVmFsdWUpfSlgfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5lIHgyPXsxMH0gc3Ryb2tlPXtcIndoaXRlXCJ9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dCBzdHlsZT17eyB0ZXh0QW5jaG9yOidlbmQnLCBmb250U2l6ZTonMTJweCd9fSBmaWxsPXsnd2hpdGUnfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aWNrVmFsdWV9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+IH0pfVxuICAgICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBYQXhpcyhwcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtkYXRhLCBzeHMsIHdpZHRoLCBoZWlnaHQsIHR5cGV9ID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgY29uc3QganVkZ2UgPSB0eXBlID09ICdzY2F0dGVyJztcbiAgICAgICAgICAgICAgICBjb25zdCBqdWRnZTIgPSB0eXBlID09ICdwcmljZSc7XG4gICAgICAgICAgICAgICAgaWYgKGp1ZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tzID0gc3hzLnRpY2tzKDEwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmUgeTE9e2hlaWdodH0geDI9e3dpZHRofSB5Mj17aGVpZ2h0fSBzdHJva2UgPXtcIndoaXRlXCJ9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGV4dCBzdHlsZT17eyBmb250OiAnc2Fucy1zZXJpZicsIGZvbnRTaXplOiAnMTRweCcgfX0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgzNjAsIDI3MClgfSB5PXsyMH0gZmlsbD17J3doaXRlJ30+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J1RyYWRpbmcgVm9sdW1lICgxZTMpJ30gXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICB7dGlja3MubWFwKCB0aWNrVmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZyBrZXk9e3RpY2tWYWx1ZX0gdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7c3hzKHRpY2tWYWx1ZSl9LCAke2hlaWdodH0pYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGluZSB5Mj17NX0gc3Ryb2tlPXtcIndoaXRlXCJ9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dCBzdHlsZT17eyB0ZXh0QW5jaG9yOidtaWRkbGUnLCBmb250U2l6ZTonMTJweCcsIGNvbG9yOid3aGl0ZSd9fSBmaWxsPXsnd2hpdGUnfSB5PXsyMH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGlja1ZhbHVlfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqdWRnZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmUgeTE9e2hlaWdodH0geDI9e3dpZHRofSB5Mj17aGVpZ2h0fSBzdHJva2UgPXtcIndoaXRlXCJ9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICB7ZGF0YS5tYXAoZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPHRleHQgc3R5bGU9e3sgZm9udDogJ3NhbnMtc2VyaWYnLCBmb250U2l6ZTogJzEycHgnIH19IGZpbGw9eyd3aGl0ZSd9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3N4cyhkLm1vbnRoKX0sIDI5MylgfSB5PXsyMH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZC5tb250aH0gXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGluZSB5MT17aGVpZ2h0fSB4Mj17d2lkdGh9IHkyPXtoZWlnaHR9IHN0cm9rZSA9e1wid2hpdGVcIn0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtkYXRhLm1hcChkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8dGV4dCBzdHlsZT17eyBmb250OiAnc2Fucy1zZXJpZicsIGZvbnRTaXplOiAnMTJweCcgfX0gIGZpbGw9eyd3aGl0ZSd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7c3hzKGQuUHJvZHVjdCl9LCAyOTMpYH0geT17MjB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2QuUHJvZHVjdH0gXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gUG9pbnRzKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocHJvcHMuc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgY29uc3Qge2RhdGEsIHN4cywgc3lzfSA9IHByb3BzO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKDEpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpe3JldHVybiBkLm1vbnRoID09ICdNYXknICYgZC5Qcm9kdWN0ID09ICdZb3JrIFN0J30pKVxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIG9uTW91c2VFbnRlcihkKXtcbiAgICAgICAgICAgICAgICAvLyAgICAgcHJvcHMuc2V0c2VsZWN0ZWQoZClcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gb25Nb3VzZU91dCgpe1xuICAgICAgICAgICAgICAgIC8vICAgICBwcm9wcy5zZVxuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlT3ZlciA9IGQgPT57XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldHNlbGVjdGVkKGQuUHJvZHVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldHRvcChzeXMoZC5zaGFycGUpKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0bGVmdChzeHMoZC50di8xMDAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldGRhdGExKGQuc2hhcnBlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0ZGF0YTIoZC50dik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlT3V0ID0gKCkgPT57XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldHNlbGVjdGVkKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXR0b3AobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBkID0+IGQudHYgPT09IDAgPyBcInllbGxvd1wiIFxuICAgICAgICAgICAgICAgICAgICAgICAgOmQuUHJvZHVjdCA9PT0gcHJvcHMuc2VsZWN0ZWQgPyBcInN0ZWVsYmx1ZVwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgOmQuc2hhcnBlID4gMj8gJ3JlZCc6J2dyZWVuJztcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSBkID0+IGQuUHJvZHVjdCA9PT0gcHJvcHMuc2VsZWN0ZWQgPyA3IDogNTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGEgPSBkID0+IGQgPT09IG51bGwgPyAwIDogMC44O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wYTIgPSBkID0+IGQgPT09IG51bGwgPyAwIDogMC44O1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRkYXRhID0gZGF0YS5maWx0ZXIoZCA9PiBkLlByb2R1Y3Q9PT1wcm9wcy5zZWxlY3RlZClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnd29ya3M/JylcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzZWxlY3RlZGRhdGFbMF0pXG4gICAgICAgICAgICAgICAgaWYoc2VsZWN0ZWRkYXRhWzBdKXtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0dG9wKHN5cyhzZWxlY3RlZGRhdGFbMF0uc2hhcnBlKS01MCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldGxlZnQoc3hzKHNlbGVjdGVkZGF0YVswXS50di8xMDAwKSsyMCk7fVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxnPlxuICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgICAgICB7ZGF0YS5tYXAoZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGNpcmNsZSBrZXk9e2QuUHJvZHVjdH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g9e3N4cyhkLnR2LzEwMDApfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeT17c3lzKGQuc2hhcnBlKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcj17cmFkaXVzKGQpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvcihkKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPXsnd2hpdGUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyPXsoKSA9PiB7bW91c2VPdmVyKGQpfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHt7dHJhbnNpdGlvbjpcIjFzXCJ9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+O1xuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAge2RhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpe3JldHVybiBkLlByb2R1Y3QgPT0gcHJvcHMuc2VsZWN0ZWR9KS5tYXAoZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGNpcmNsZSBrZXk9e2QuUHJvZHVjdH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g9e3N4cyhkLnR2LzEwMDApfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeT17c3lzKGQuc2hhcnBlKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcj17cmFkaXVzKGQpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvcihkKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPXsnd2hpdGUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VPdXQ9e21vdXNlT3V0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0ge3t0cmFuc2l0aW9uOlwiMTAwc1wifX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPjtcbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgIDxyZWN0ICB4ID0ge3Byb3BzLmxlZnR9IHk9e3Byb3BzLnRvcH0gb3BhY2l0eT17b3BhKHByb3BzLnNlbGVjdGVkKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXsxODB9IGhlaWdodCA9IHs5MH0gZmlsbD17J2xpZ2h0Ymx1ZSd9Lz5cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0IHN0eWxlPXt7IGZvbnQ6ICdzYW5zLXNlcmlmJywgZm9udFNpemU6ICcxMnB4JyB9fSAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7cHJvcHMubGVmdH0sICR7cHJvcHMudG9wfSlgfSB4PXs1fSB5PXszMH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5PXtvcGEyKHByb3BzLnNlbGVjdGVkKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cHJvcHMuc2VsZWN0ZWR9ICBcbiAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICAgICAgICA8dGV4dCBzdHlsZT17eyBmb250OiAnc2Fucy1zZXJpZicsIGZvbnRTaXplOiAnMTJweCcgfX0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3Byb3BzLmxlZnR9LCAke3Byb3BzLnRvcH0pYH0geD17MjV9IHk9ezUwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9e29wYTIocHJvcHMuc2VsZWN0ZWQpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcIsOCwrcgVHJhZGluZyBWb2x1bWU6IFwifSAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TWF0aC5yb3VuZChwcm9wcy5kYXRhMil9ICBcbiAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICAgICAgICA8dGV4dCBzdHlsZT17eyBmb250OiAnc2Fucy1zZXJpZicsIGZvbnRTaXplOiAnMTJweCcgfX0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3Byb3BzLmxlZnR9LCAke3Byb3BzLnRvcH0pYH0geD17MjV9IHk9ezcwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9e29wYTIocHJvcHMuc2VsZWN0ZWQpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcIsOCwrcgU2hhcnBlIFJhdGlvOiBcIn0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge01hdGguZmxvb3IocHJvcHMuZGF0YTEgKiAxMDApIC8gMTAwfSAgXG4gICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gT3ZlclBvaW50cyhwcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHByb3BzLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIGNvbnN0IHtkYXRhLCBzeHMsIHN5c30gPSBwcm9wcztcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygxKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhkYXRhLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gZC5tb250aCA9PSAnTWF5JyAmIGQuUHJvZHVjdCA9PSAnWW9yayBTdCd9KSlcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBvbk1vdXNlRW50ZXIoZCl7XG4gICAgICAgICAgICAgICAgLy8gICAgIHByb3BzLnNldHNlbGVjdGVkKGQpXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIG9uTW91c2VPdXQoKXtcbiAgICAgICAgICAgICAgICAvLyAgICAgcHJvcHMuc2VcbiAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZU92ZXIgPSBkID0+e1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXRzZWxlY3RlZChkLlByb2R1Y3QpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXR0b3Aoc3lzKGQubWF4aSkpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXRsZWZ0KHN4cyhkLlByb2R1Y3QpKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0ZGF0YTEoZC5zaGFycGUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXRkYXRhMihkLnR2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VPdXQgPSAoKSA9PntcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0c2VsZWN0ZWQobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldHRvcChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGQgPT4gZC50diA9PT0gMCA/IFwieWVsbG93XCIgXG4gICAgICAgICAgICAgICAgICAgICAgICA6ZC5Qcm9kdWN0ID09PSBwcm9wcy5zZWxlY3RlZCA/IFwic3RlZWxibHVlXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICA6ZC5zaGFycGUgPiAyPyAncmVkJzonZ3JlZW4nO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IGQgPT4gZC5Qcm9kdWN0ID09PSBwcm9wcy5zZWxlY3RlZCA/IDEwIDogNTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGEgPSBkID0+IGQgPT09IG51bGwgPyAwIDogMC44O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wYTIgPSBkID0+IGQgPT09IG51bGwgPyAwIDogMC44O1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRkYXRhID0gZGF0YS5maWx0ZXIoZCA9PiBkLlByb2R1Y3Q9PT1wcm9wcy5zZWxlY3RlZClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnd29ya3M/JylcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzZWxlY3RlZGRhdGFbMF0pXG4gICAgICAgICAgICAgICAgaWYoc2VsZWN0ZWRkYXRhWzBdKXtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0dG9wKHN5cyhzZWxlY3RlZGRhdGFbMF0ubWF4aSktNTApO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXRsZWZ0KHN4cyhzZWxlY3RlZGRhdGFbMF0uUHJvZHVjdCkrMjApO31cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFycCA9IGQgPT4gZD8gZC5zaGFycGU6IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4aSA9IGQgPT4gZD8gZC5tYXhpOiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbmkgPSBkID0+IGQ/IGQubWluaTogMDtcblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxnPlxuXG4gICAgICAgICAgICAgICAgICAgIHtkYXRhLm1hcChkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8Y2lyY2xlIGtleT17ZC5Qcm9kdWN0fSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeD17c3hzKGQuUHJvZHVjdCl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5PXtzeXMoZC5zaGFycGUpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByPXtyYWRpdXMoZCl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9e2NvbG9yKGQpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9eyd3aGl0ZSd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU92ZXI9eygpID0+IHttb3VzZU92ZXIoZCl9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0ge3t0cmFuc2l0aW9uOlwiMXNcIn19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz47XG4gICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICB7ZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuIGQuUHJvZHVjdCA9PSBwcm9wcy5zZWxlY3RlZH0pLm1hcChkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8Y2lyY2xlIGtleT17ZC5Qcm9kdWN0fSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeD17c3hzKGQuUHJvZHVjdCl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5PXtzeXMoZC5zaGFycGUpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByPXtyYWRpdXMoZCl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9e2NvbG9yKGQpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9eyd3aGl0ZSd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU91dD17bW91c2VPdXR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSB7e3RyYW5zaXRpb246XCIxMDBzXCJ9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+O1xuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAge2RhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpe3JldHVybiBkLlByb2R1Y3QgPT0gcHJvcHMuc2VsZWN0ZWR9KS5tYXAoZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGNpcmNsZSBrZXk9e2QuUHJvZHVjdH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g9e3N4cyhkLlByb2R1Y3QpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeT17c3lzKGQubWluaSl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI9e3JhZGl1cyhkKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD17Y29sb3IoZCl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT17J3doaXRlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlT3V0PXttb3VzZU91dH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHt7dHJhbnNpdGlvbjpcIjEwMHNcIn19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz47XG4gICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICB7ZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuIGQuUHJvZHVjdCA9PSBwcm9wcy5zZWxlY3RlZH0pLm1hcChkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8Y2lyY2xlIGtleT17ZC5Qcm9kdWN0fSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeD17c3hzKGQuUHJvZHVjdCl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5PXtzeXMoZC5tYXhpKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcj17cmFkaXVzKGQpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvcihkKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPXsnd2hpdGUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VPdXQ9e21vdXNlT3V0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0ge3t0cmFuc2l0aW9uOlwiMTAwc1wifX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPjtcbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgIDxyZWN0ICB4ID0ge3Byb3BzLmxlZnR9IHk9e3Byb3BzLnRvcH0gb3BhY2l0eT17b3BhKHByb3BzLnNlbGVjdGVkKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXsxODB9IGhlaWdodCA9IHsxMTB9IGZpbGw9eydsaWdodGJsdWUnfS8+XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICA8dGV4dCBzdHlsZT17eyBmb250OiAnc2Fucy1zZXJpZicsIGZvbnRTaXplOiAnMTJweCcgfX0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3Byb3BzLmxlZnR9LCAke3Byb3BzLnRvcH0pYH0geD17NX0geT17MzB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eT17b3BhMihwcm9wcy5zZWxlY3RlZCl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3Byb3BzLnNlbGVjdGVkfSAgXG4gICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgZm9udDogJ3NhbnMtc2VyaWYnLCBmb250U2l6ZTogJzEycHgnIH19ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHtwcm9wcy5sZWZ0fSwgJHtwcm9wcy50b3B9KWB9IHg9ezI1fSB5PXs1MH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5PXtvcGEyKHByb3BzLnNlbGVjdGVkKX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XCLDgsK3IE1heCBTaGFycGUgUmF0aW86IFwifSAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7TWF0aC5mbG9vcihtYXhpKHNlbGVjdGVkZGF0YVswXSkqMTAwKS8xMDB9ICBcbiAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICAgICAgICA8dGV4dCBzdHlsZT17eyBmb250OiAnc2Fucy1zZXJpZicsIGZvbnRTaXplOiAnMTJweCcgfX0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3Byb3BzLmxlZnR9LCAke3Byb3BzLnRvcH0pYH0geD17MjV9IHk9ezcwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk9e29wYTIocHJvcHMuc2VsZWN0ZWQpfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcIsOCwrcgTWluIFNoYXJwZSBSYXRpbzogXCJ9ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtNYXRoLmZsb29yKG1pbmkoc2VsZWN0ZWRkYXRhWzBdKSoxMDApLzEwMH0gIFxuICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0IHN0eWxlPXt7IGZvbnQ6ICdzYW5zLXNlcmlmJywgZm9udFNpemU6ICcxMnB4JyB9fSAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7cHJvcHMubGVmdH0sICR7cHJvcHMudG9wfSlgfSB4PXsyNX0geT17OTB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eT17b3BhMihwcm9wcy5zZWxlY3RlZCl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1wiw4LCtyBBdmcgU2hhcnBlIFJhdGlvOiBcIn0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge01hdGguZmxvb3Ioc2hhcnAoc2VsZWN0ZWRkYXRhWzBdKSAqIDEwMCkgLyAxMDB9ICBcbiAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gU2NhdHRlclBsb3QocHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcHJvcHMuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtyZXR1cm4gPHByZT5Mb2FkaW5nLi4uPC9wcmU+O307XG4gICAgICAgICAgICAgICAgY29uc3QgV0lEVEggPSA2MDA7XG4gICAgICAgICAgICAgICAgY29uc3QgSEVJR0hUID0gODAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChIRUlHSFQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSkvMjtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IFdJRFRIIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQgLSAyMDtcbiAgICAgICAgICAgICAgICBjb25zdCBzeHMgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgKGQpPT4gZC50di8xMDAwKV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5uaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZDMubWF4KGRhdGEsIChkKT0+IGQuc2hhcnBlKSlcbiAgICAgICAgICAgICAgICBjb25zdCBzeXMgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgZDMubWF4KGRhdGEsIChkKT0+IGQuc2hhcnBlKV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5uaWNlKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0KzU1MCtwcm9wcy5hZGRtb3JlfSwgJHttYXJnaW4udG9wKzUwfSlgfT5cbiAgICAgICAgICAgICAgICAgICAgPFBvaW50cyBkYXRhPXtwcm9wcy5kYXRhfSBzeHM9e3N4c30gc3lzPXtzeXN9IGNvbG9yPXsnc3RlZWxibHVlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17cHJvcHMuc2VsZWN0ZWR9IHNldHNlbGVjdGVkPXtwcm9wcy5zZXRzZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aD17cHJvcHMubW9udGh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wPXtwcm9wcy50b3B9IHNldHRvcD17cHJvcHMuc2V0dG9wfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ9e3Byb3BzLmxlZnR9IHNldGxlZnQ9e3Byb3BzLnNldGxlZnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTE9e3Byb3BzLmRhdGExfSBzZXRkYXRhMT17cHJvcHMuc2V0ZGF0YTF9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTI9e3Byb3BzLmRhdGEyfSBzZXRkYXRhMj17cHJvcHMuc2V0ZGF0YTJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTM9e3Byb3BzLmRhdGEzfSBzZXRkYXRhMz17cHJvcHMuc2V0ZGF0YTN9Lz5cbiAgICAgICAgICAgICAgICAgICAgPFlBeGlzIHN5cz17c3lzfSB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSB0eXBlPXsnc2NhdHRlcid9Lz5cbiAgICAgICAgICAgICAgICAgICAgPFhBeGlzIHN4cz17c3hzfSB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSB0eXBlPXsnc2NhdHRlcid9Lz5cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE92ZXJTY2F0dGVyUGxvdChwcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwcm9wcy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge3JldHVybiA8cHJlPkxvYWRpbmcuLi48L3ByZT47fTtcbiAgICAgICAgICAgICAgICBjb25zdCBXSURUSCA9IDYwMDtcbiAgICAgICAgICAgICAgICBjb25zdCBIRUlHSFQgPSA4MDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKEhFSUdIVCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKS8yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gV0lEVEggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCAtIDIwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN4cyA9IGQzLnNjYWxlQmFuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGRhdGEubWFwKGQgPT4ge3JldHVybiBkLlByb2R1Y3R9KSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3lzID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIGQzLm1heChkYXRhLCAoZCk9PiBkLm1heGkpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5pY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnd2hhdHMgd3JvbmcnKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxnIHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0KzU1MCtwcm9wcy5hZGRtb3JlfSwgJHttYXJnaW4udG9wKzUwfSlgfT5cbiAgICAgICAgICAgICAgICAgICAgPE92ZXJQb2ludHMgZGF0YT17cHJvcHMuZGF0YX0gc3hzPXtzeHN9IHN5cz17c3lzfSBjb2xvcj17J3N0ZWVsYmx1ZSd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e3Byb3BzLnNlbGVjdGVkfSBzZXRzZWxlY3RlZD17cHJvcHMuc2V0c2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGg9e3Byb3BzLm1vbnRofVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcD17cHJvcHMudG9wMX0gc2V0dG9wPXtwcm9wcy5zZXR0b3AxfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ9e3Byb3BzLmxlZnQxfSBzZXRsZWZ0PXtwcm9wcy5zZXRsZWZ0MX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMT17cHJvcHMuZGF0YTF9IHNldGRhdGExPXtwcm9wcy5zZXRkYXRhMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMj17cHJvcHMuZGF0YTJ9IHNldGRhdGEyPXtwcm9wcy5zZXRkYXRhMn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMz17cHJvcHMuZGF0YTN9IHNldGRhdGEzPXtwcm9wcy5zZXRkYXRhM30vPlxuICAgICAgICAgICAgICAgICAgICA8WUF4aXMgc3lzPXtzeXN9IHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IHR5cGU9eydzY2F0dGVyJ30vPlxuICAgICAgICAgICAgICAgICAgICA8WEF4aXMgZGF0YT17cHJvcHMuZGF0YX0gc3hzPXtzeHN9IHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IHR5cGU9eydiYXInfS8+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJhcnMocHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc2VsZWN0ZWQsIHNldHNlbGVjdGVkXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpXG4gICAgICAgICAgICAgICAgY29uc3Qge2RhdGEsIHN4cywgc3lzLCBieHMsIGJ5cywgYnkyfSA9IHByb3BzO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIG9uTW91c2VFbnRlcihkKXtcbiAgICAgICAgICAgICAgICAvLyAgICAgcHJvcHMuc2V0c2VsZWN0ZWQoZClcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gb25Nb3VzZU91dCgpe1xuICAgICAgICAgICAgICAgIC8vICAgICBwcm9wcy5zZVxuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlT3ZlciA9IGQgPT57XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldHNlbGVjdGVkKGQuUHJvZHVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldHRvcChzeXMoZC5zaGFycGUpKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0bGVmdChzeHMoZC50di8xMDAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldGRhdGExKGQuc2hhcnBlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0ZGF0YTIoZC50dik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlT3V0ID0gKCkgPT57XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldHNlbGVjdGVkKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXR0b3AobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBkID0+IGQuUHJvZHVjdCA9PT0gcHJvcHMuc2VsZWN0ZWQgPyBcInN0ZWVsYmx1ZVwiIDogXCJ5ZWxsb3dcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvcjIgPSBkID0+IGQuUHJvZHVjdCA9PT0gcHJvcHMuc2VsZWN0ZWQgPyBcInN0ZWVsYmx1ZVwiIDogXG4gICAgICAgICAgICAgICAgZC5tdi9tYXhtdioxMDAgPiBkLnR2L21heHR2KjEwMCA/IFwiZ3JlZW5cIiA6IFwicmVkXCI7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXh0diA9IGQzLm1heChkYXRhLCAoZCk9PiBkLnR2KVxuICAgICAgICAgICAgICAgIGNvbnN0IG1heG12ID0gZDMubWF4KGRhdGEsIChkKT0+IGQubXYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxnPlxuICAgICAgICAgICAgICAgICAgICB7ZGF0YS5tYXAoZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPHJlY3Qga2V5PXtkLlByb2R1Y3R9IHg9e2J4cyhkLlByb2R1Y3QpfSB5PXtieXMoZC5tdi9tYXhtdioxMDApfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17MTB9IGhlaWdodD17MzAwLWJ5cyhkLm12L21heG12KjEwMCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD17Y29sb3IoZCl9IHN0cm9rZT17J3doaXRlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlT3Zlcj17KCkgPT4ge21vdXNlT3ZlcihkKX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU91dD17bW91c2VPdXR9Lz5cbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgIHtkYXRhLm1hcChkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8cmVjdCBrZXk9e2QuUHJvZHVjdH0geD17YnhzKGQuUHJvZHVjdCkrMTB9IHk9e2J5MihkLnR2L21heHR2KjEwMCl9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPXsxMH0gaGVpZ2h0PXszMDAtYnkyKGQudHYvbWF4dHYqMTAwKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvcjIoZCl9IHN0cm9rZT17J3doaXRlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlT3Zlcj17KCkgPT4ge21vdXNlT3ZlcihkKX19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZU91dD17bW91c2VPdXR9Lz5cbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBCYXJDaGFydChwcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwcm9wcy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge3JldHVybiA8cHJlPkxvYWRpbmcuLi48L3ByZT47fTtcbiAgICAgICAgICAgICAgICBjb25zdCBXSURUSCA9IDYwMDtcbiAgICAgICAgICAgICAgICBjb25zdCBIRUlHSFQgPSA4MDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKEhFSUdIVCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKS8yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gV0lEVEggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCAtIDIwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN4cyA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIGQzLm1heChkYXRhLCAoZCk9PiBkLnR2LzEwMDApXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5pY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzeXMgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgZDMubWF4KGRhdGEsIChkKT0+IGQuc2hhcnBlKV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5uaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnhzID0gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oZGF0YS5tYXAoZCA9PiB7cmV0dXJuIGQuUHJvZHVjdH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBieXMgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbMCwxMDBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubmljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5MiA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFswLCAxMDBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubmljZSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHttYXJnaW4ubGVmdCs1NTB9LCAke21hcmdpbi50b3AraGVpZ2h0KzEwMH0pYH0+XG4gICAgICAgICAgICAgICAgICAgIDxCYXJzIGRhdGE9e3Byb3BzLmRhdGF9IHN4cz17c3hzfSBzeXM9e3N5c30gYnhzPXtieHN9IGJ5cz17YnlzfSBieTI9e2J5Mn1cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e3Byb3BzLnNlbGVjdGVkfSBzZXRzZWxlY3RlZD17cHJvcHMuc2V0c2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgIHRvcD17cHJvcHMudG9wfSBzZXR0b3A9e3Byb3BzLnNldHRvcH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0PXtwcm9wcy5sZWZ0fSBzZXRsZWZ0PXtwcm9wcy5zZXRsZWZ0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGExPXtwcm9wcy5kYXRhMX0gc2V0ZGF0YTE9e3Byb3BzLnNldGRhdGExfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEyPXtwcm9wcy5kYXRhMn0gc2V0ZGF0YTI9e3Byb3BzLnNldGRhdGEyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEzPXtwcm9wcy5kYXRhM30gc2V0ZGF0YTM9e3Byb3BzLnNldGRhdGEzfVxuICAgICAgICAgICAgICAgICAgICBtb250aD17cHJvcHMubW9udGh9Lz5cbiAgICAgICAgICAgICAgICAgICAgPFlBeGlzIHN5cz17YnlzfSB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSB0eXBlPXsnYmFyJ30vPlxuICAgICAgICAgICAgICAgICAgICA8WUF4aXMgc3lzPXtieTJ9IHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IHR5cGU9eydiYXIyJ30vPlxuICAgICAgICAgICAgICAgICAgICA8WEF4aXMgZGF0YT17cHJvcHMuZGF0YX0gc3hzPXtieHN9IHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IHR5cGU9eydiYXInfS8+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBTeW1tZXRyaWNBcmVhQ2hhcnQocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZLCBkYXRhLCBoZWlnaHQsIHdpZHRoIH0gPSBwcm9wcztcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgdGV4dCBuZWVkZWQgaXMgZ2l2ZW4gaW4gdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeFNjYWxlID0gZDMuc2NhbGVCYW5kKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oWycwMScsJzAyJywnMDMnLCcwNCcsJzA1JywnMDYnLCcwNycsJzA4JywnMDknLCcxMCcsJzExJywnMTInXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIGQzLm1heChbZDMubWF4KGRhdGEsIGQgPT4gZC5sb3cpLGQzLm1heChkYXRhLCBkID0+IGQubWF4KV0pXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2UoW2hlaWdodC8yLCAwXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubmljZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwMSA9IGQzLmFyZWEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAueChkID0+IHhTY2FsZShkLm1vbnRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnkwKGhlaWdodC8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAueTEoZCA9PiB5U2NhbGUoZC5sb3cpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gZDMuYXJlYSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC54KGQgPT4geFNjYWxlKGQubW9udGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAueTAoaGVpZ2h0LzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC55MShkID0+IHlTY2FsZSgtZC5tYXgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAzID0gZDMuYXJlYSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC54KGQgPT4geFNjYWxlKGQubW9udGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAueTAoaGVpZ2h0LzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC55MShkID0+IHlTY2FsZShkLm1lYW4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzeW1tJylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSlcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7NjAwfSwgJHswfSlgfSA+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9e3AxfSBmaWxsPXsnbGlnaHRncmVlbid9IHN0cm9rZT17J3doaXRlJ30gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9e3AzfSBmaWxsPXsnYmx1ZSd9IHN0cm9rZT17J3doaXRlJ30gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9e3AyfSBmaWxsPXsncmVkJ30gc3Ryb2tlPXsnd2hpdGUnfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHs8bGluZSB5Mj17aGVpZ2h0fSBzdHJva2U9J3doaXRlJyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoMCwgMClgfSAvPiB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt4U2NhbGUuZG9tYWluKCkubWFwKHRpY2tWYWx1ZSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyBrZXk9e3RpY2tWYWx1ZSsnQid9IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3hTY2FsZSh0aWNrVmFsdWUpLTEwfSwgMzApYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGluZSB5Mj17MTB9IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgxMCwgJHtoZWlnaHQtMjJ9KWB9IHN0cm9rZT0nd2hpdGUnLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHN0eWxlPXt7dGV4dEFuY2hvcjogJ3N0YXJ0JywgZm9udFNpemU6JzEycHgnIH19IHk9e2hlaWdodH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17YHJvdGF0ZSgwLCAwLCAke2hlaWdodCszfSlgfT4ge3RpY2tWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHt5U2NhbGUudGlja3MoMikubWFwKHRpY2tWYWx1ZSA9PiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZyBrZXk9e3RpY2tWYWx1ZX0gdHJhbnNmb3JtPXtgdHJhbnNsYXRlKC0xMCwgJHt5U2NhbGUodGlja1ZhbHVlKX0pYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5lIHgyPXsxMH0gc3Ryb2tlPSd3aGl0ZScgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgdGV4dEFuY2hvcjonZW5kJywgZm9udFNpemU6JzEwcHgnIH19ID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aWNrVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB7eVNjYWxlLnRpY2tzKDIpLnJldmVyc2UoKS5tYXAodGlja1ZhbHVlID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxnIGtleT17dGlja1ZhbHVlfSB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoLTEwLCAke2hlaWdodC15U2NhbGUodGlja1ZhbHVlKX0pYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaW5lIHgyPXsxMH0gc3Ryb2tlPSd3aGl0ZScgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgdGV4dEFuY2hvcjonZW5kJywgZm9udFNpemU6JzEwcHgnIH19ID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aWNrVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB7PGxpbmUgeDE9ezYwMH0geTE9e2hlaWdodC8yfSB4Mj17MTAwMH0geTI9e2hlaWdodC8yfSBzdHJva2U9J3doaXRlJy8+fVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHN0eWxlPXt7IHRleHRBbmNob3I6J2VuZCcsIGZvbnRTaXplOicxNXB4J319IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3dpZHRofSwgJHsyMH0pcm90YXRlKDApYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcIlN0YXJ0XCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgdGV4dEFuY2hvcjonZW5kJywgZm9udFNpemU6JzE1cHgnfX0gdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7d2lkdGgqMi8zfSwgJHstMTB9KXJvdGF0ZSgwKWB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XCJOdW0uIG9mIHJpZGVycyBvdmVyIHRoZSB5ZWFyXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7b2Zmc2V0WH0sICR7b2Zmc2V0WStoZWlnaHQvMn0pYH0+ICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0IHN0eWxlPXt7IHRleHRBbmNob3I6J2VuZCcsIGZvbnRTaXplOicxNXB4J319IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgke3dpZHRofSwgJHtoZWlnaHQvMi0yMH0pcm90YXRlKDApYH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcIkVuZFwifVxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZXh0PlxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBQYXRoZHJhdyhwcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHByb3BzLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIGNvbnN0IHtkYXRhLCBzeHMsIHN5c30gPSBwcm9wcztcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVhbGx5Pz8/PycpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN4cygnMDInKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuIGQubW9udGggPT0gJ01heScgJiBkLlByb2R1Y3QgPT0gJ1lvcmsgU3QnfSkpXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gb25Nb3VzZUVudGVyKGQpe1xuICAgICAgICAgICAgICAgIC8vICAgICBwcm9wcy5zZXRzZWxlY3RlZChkKVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBvbk1vdXNlT3V0KCl7XG4gICAgICAgICAgICAgICAgLy8gICAgIHByb3BzLnNlXG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VPdmVyID0gZCA9PntcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0c2VsZWN0ZWQoZC5Qcm9kdWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0dG9wKHN5cyhkLnNoYXJwZSkpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXRsZWZ0KHN4cyhkLnR2LzEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0ZGF0YTEoZC5zaGFycGUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zZXRkYXRhMihkLnR2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VPdXQgPSAoKSA9PntcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2V0c2VsZWN0ZWQobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNldHRvcChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IGQgPT4gZC5tb250aCA9PT0gcHJvcHMuY3VycmVudG1vbnRoID8gJ3N0ZWVsYmx1ZScgOiAnYmxhY2snO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IGQgPT4gZC5tb250aCA9PT0gcHJvcHMuY3VycmVudG1vbnRoID8gNSA6IDM7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BhID0gZCA9PiBkID09PSBudWxsID8gMCA6IDAuNjtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGEyID0gZCA9PiBkID09PSBudWxsID8gMCA6IDAuODtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHAxID0gZDMuYXJlYSgpXG4gICAgICAgICAgICAgICAgICAgIC54KGQgPT4gc3hzKGQubW9udGgpKzEwKVxuICAgICAgICAgICAgICAgICAgICAueTAoMzAwKVxuICAgICAgICAgICAgICAgICAgICAueTEoZCA9PiBzeXMoZC5tYXgpKVxuICAgICAgICAgICAgICAgICAgICAuY3VydmUoZDMuY3VydmVCYXNpcylcbiAgICAgICAgICAgICAgICAgICAgKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcDIgPSBkMy5hcmVhKClcbiAgICAgICAgICAgICAgICAgICAgLngoZCA9PiBzeHMoZC5tb250aCkrMTApXG4gICAgICAgICAgICAgICAgICAgIC55MCgzMDApXG4gICAgICAgICAgICAgICAgICAgIC55MShkID0+IHN5cyhkLmxvdykpXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKVxuICAgICAgICAgICAgICAgICAgICAoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwMyA9IGQzLmFyZWEoKVxuICAgICAgICAgICAgICAgICAgICAueChkID0+IHN4cyhkLm1vbnRoKSsxMClcbiAgICAgICAgICAgICAgICAgICAgLnkwKDMwMClcbiAgICAgICAgICAgICAgICAgICAgLnkxKGQgPT4gc3lzKGQubWVhbikpXG4gICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKVxuICAgICAgICAgICAgICAgICAgICAoZGF0YSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gPGc+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9e3AxfSBmaWxsPXsncmVkJ30gc3Ryb2tlPXsnd2hpdGUnfSAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPXtwM30gZmlsbD17J2xpZ2h0Z3JlZW4nfSBzdHJva2U9eyd3aGl0ZSd9IC8+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9e3AyfSBmaWxsPXsnYmxhY2snfSBzdHJva2U9eyd3aGl0ZSd9IC8+XG4gICAgICAgICAgICAgICAgICAgIHtkYXRhLm1hcChkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8Y2lyY2xlIGN4PXtzeHMoZC5tb250aCkrMTB9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5PXtzeXMoZC5tZWFuKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcj17cmFkaXVzKGQpfSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvcihkKX0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPXsnd2hpdGUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyPXsoKSA9PiB7bW91c2VPdmVyKGQpfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHt7dHJhbnNpdGlvbjpcIjFzXCJ9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+O1xuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICB9XG4gICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIFByaWNlQ3VydmUocHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcHJvcHMuZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtyZXR1cm4gPHByZT5Mb2FkaW5nLi4uPC9wcmU+O307XG4gICAgICAgICAgICAgICAgY29uc3QgV0lEVEggPSA2MDA7XG4gICAgICAgICAgICAgICAgY29uc3QgSEVJR0hUID0gODAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IChIRUlHSFQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSkvMjtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IFdJRFRIIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQgLSAyMDtcbiAgICAgICAgICAgICAgICBjb25zdCBzeHMgPSBkMy5zY2FsZUJhbmQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihkYXRhLm1hcChkID0+IHtyZXR1cm4gZC5tb250aH0pKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncHJpY2VwcmljZXByaWNlJylcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkMy5tYXgoZGF0YSwgKGQpPT4gZC5zaGFycGUpKVxuICAgICAgICAgICAgICAgIGNvbnN0IHN5cyA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBkMy5tYXgoZGF0YSwgKGQpPT4gZC5tYXgpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5pY2UoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBtb3JlJylcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2PiBcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKSAgIFxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJldHVybiA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHttYXJnaW4ubGVmdCsyMH0sICR7bWFyZ2luLnRvcCtoZWlnaHQrMTAwfSlgfT5cbiAgICAgICAgICAgICAgICAgICAgPFBhdGhkcmF3IGRhdGE9e3Byb3BzLmRhdGF9IHN4cz17c3hzfSBzeXM9e3N5c30gY29sb3I9eydzdGVlbGJsdWUnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXtwcm9wcy5zZWxlY3RlZH0gc2V0c2VsZWN0ZWQ9e3Byb3BzLnNldHNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoPXtwcm9wcy5tb250aH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A9e3Byb3BzLnRvcH0gc2V0dG9wPXtwcm9wcy5zZXR0b3B9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdD17cHJvcHMubGVmdH0gc2V0bGVmdD17cHJvcHMuc2V0bGVmdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMT17cHJvcHMuZGF0YTF9IHNldGRhdGExPXtwcm9wcy5zZXRkYXRhMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMj17cHJvcHMuZGF0YTJ9IHNldGRhdGEyPXtwcm9wcy5zZXRkYXRhMn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMz17cHJvcHMuZGF0YTN9IHNldGRhdGEzPXtwcm9wcy5zZXRkYXRhM31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50bW9udGg9e3Byb3BzLmN1cnJlbnRtb250aH0vPlxuICAgICAgICAgICAgICAgICAgICA8WUF4aXMgc3lzPXtzeXN9IHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IHR5cGU9eydwcmljZSd9Lz5cbiAgICAgICAgICAgICAgICAgICAgPFhBeGlzIGRhdGE9e3Byb3BzLmRhdGF9IHN4cz17c3hzfSB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSB0eXBlPXsncHJpY2UnfS8+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gVG9vbHRpcChwcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtkLCBzdGF0aW9uWWVhckRhdGEsIGxlZnQsIHRvcCwgaGVpZ2h0LCB3aWR0aH0gPSBwcm9wcztcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZCA9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ25vIG1vcmUnKVxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+IFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApICAgXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRpb25ZZWFyRGF0YSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2hlcmUnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7bGVmdH0sICR7dG9wfSlgfT5cbiAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgdGV4dEFuY2hvcjonc3RhcnQnLCBmb250U2l6ZTonMTVweCd9fSAgdHJhbnNmb3JtPXtgdHJhbnNsYXRlKCR7MH0sICR7LTV9KXJvdGF0ZSgwKWB9PntkLlByb2R1Y3R9IDwvdGV4dD5cbiAgICAgICAgICAgICAgICAgICAgPFByaWNlQ3VydmUgZGF0YT17c3RhdGlvblllYXJEYXRhfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRtb3JlPXs2MDB9Lz5cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgKSAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgQ2hhcnRzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IEhvbWVfcGFnZSA9ICgpID0+IHsgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZiA9ICdpbmRleC5odG1sJyBmaWxsID0gJ3doaXRlJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3MgPSAnYnV0dG9uJz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dCBzdHlsZT17eyB0ZXh0QW5jaG9yOidib3R0b20nLCBmb250U2l6ZTonMmVtJ319IGZpbGwgPSAnd2hpdGUnIHggPSB7XCIwJVwifSB5ID0ge1wiMFwifT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5mb3JtYXRpb24gVml6dWFsaXphdGlvbiBQcm9qZWN0IC0gU2hhbmdoYWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcgd2lkdGggPSAnMTAwJScgaGVpZ2h0ID0gJzEnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpbmUgIHgyPVwiMTAwJVwiIHkxPVwiMTAwJVwiIHkyPVwiMTAwJVwiIHN0cm9rZSA9IFwid2hpdGVcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmOyAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGVzdC5zcGxpdCgnPScpWzFdLnNwbGl0KCctJylbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1uID0gWycwMScsJzAyJywnMDMnLCcwNCcsJzA1JywnMDYnLCcwNycsJzA4JywnMDknLCcxMCcsJzExJywnMTInXTsgXG4gICAgICAgICAgICAgICAgY29uc3QgWUVBUiA9IFsnMjAxNycsJzIwMTgnLCcyMDE5JywnMjAyMCddO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzZWxlY3RlZCwgc2V0c2VsZWN0ZWRdID0gUmVhY3QudXNlU3RhdGUobnVsbClcbiAgICAgICAgICAgICAgICBjb25zdCBbdG9wLCBzZXR0b3BdID0gUmVhY3QudXNlU3RhdGUobnVsbClcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgc2V0bGVmdF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKVxuICAgICAgICAgICAgICAgIGNvbnN0IFt0b3AxLCBzZXR0b3AxXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpXG4gICAgICAgICAgICAgICAgY29uc3QgW2xlZnQxLCBzZXRsZWZ0MV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKVxuICAgICAgICAgICAgICAgIGNvbnN0IFtkYXRhMSwgc2V0ZGF0YTFdID0gUmVhY3QudXNlU3RhdGUobnVsbClcbiAgICAgICAgICAgICAgICBjb25zdCBbZGF0YTIsIHNldGRhdGEyXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpXG4gICAgICAgICAgICAgICAgY29uc3QgW2RhdGEzLCBzZXRkYXRhM10gPSBSZWFjdC51c2VTdGF0ZShudWxsKVxuICAgICAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgc2V0dmFsdWVdID0gUmVhY3QudXNlU3RhdGUoNClcbiAgICAgICAgICAgICAgICBjb25zdCBbbW9udGgsIHNldE1vbnRoXSA9IFJlYWN0LnVzZVN0YXRlKG1uLmluZGV4T2YodGVzdC5zcGxpdCgnPScpWzFdLnNwbGl0KCctJylbMV0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbeWVhciwgc2V0WWVhcl0gPSBSZWFjdC51c2VTdGF0ZShZRUFSLmluZGV4T2YodGVzdC5zcGxpdCgnPScpWzFdLnNwbGl0KCctJylbMF0pKTtcbiAgICAgICAgICAgICAgICBsZXQgbW9udGhsaXN0ID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU2VwJywnT2N0JywnTm92JywnRGVjJ107XG4gICAgICAgICAgICAgICAgY29uc3QgTU9OVEggPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XG4gICAgICAgICAgICAgICAgLy8gbGV0IHNsaWRlciA9IGQzLnNlbGVjdCgnI3NsaWRlcicpO1xuICAgICAgICAgICAgICAgIC8vIGxldCBzbGlkZXJ0ZXh0ID0gZDMuc2VsZWN0KCcjc2xpZGVydGV4dCcpXG4gICAgICAgICAgICAgICAgLy8gc2xpZGVyLm9uKFwiaW5wdXRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coMSlcbiAgICAgICAgICAgICAgICAvLyAgICAgc2xpZGVydGV4dC5hdHRyKCd2YWx1ZScsIG1vbnRoW3RoaXMudmFsdWUtMV0pO1xuICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFBbGwgPSB1c2VEYXRhKGNzdlVybCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIDxwcmU+TG9hZGluZy4uLjwvcHJlPjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IFdJRFRIID0gMjYwMDtcbiAgICAgICAgICAgICAgICBjb25zdCBIRUlHSFQgPSA4MDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJIZWlnaHQgPSBIRUlHSFQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lcldpZHRoID0gV0lEVEggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDsgXG5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhX3llYXIgPSBkYXRhQWxsLmZpbHRlciggZCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQueWVhciA9PSBZRUFSW3llYXJdICYgZC5FeGNoYW5nZSA9PSAnQ1pDRSc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YV9maW5hbCA9IGRhdGFfeWVhci5maWx0ZXIoIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtbiA9IFsnMDEnLCcwMicsJzAzJywnMDQnLCcwNScsJzA2JywnMDcnLCcwOCcsJzA5JywnMTAnLCcxMScsJzEyJ107IFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5tb250aCA9PSBtblttb250aF07XG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZUhhbmRsZXJNb250aCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRNb250aChldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlSGFuZGxlclllYXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0WWVhcihldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRQb2ludCA9IGRhdGFBbGwuZmlsdGVyKGQgPT4gZC5Qcm9kdWN0PT09c2VsZWN0ZWQpWzBdO1xuXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobW5bbW9udGhdKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYW5vdGhlcicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGlvblllYXJEYXRhID0gZGF0YV95ZWFyLmZpbHRlciggZD0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuUHJvZHVjdCA9PSBzZWxlY3RlZDtcbiAgICAgICAgICAgICAgICB9KTsgXG4gICAgICAgICAgICAgICAgbGV0IGFsbHByb2QgPSBkYXRhX2ZpbmFsLm1hcChkID0+IGQuUHJvZHVjdClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnd2hhdCcpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0cnkgdGhlIGF2ZXJhZ2UnKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGQzLm1lYW4oZGF0YV95ZWFyLmZpbHRlcihkID0+IGQuUHJvZHVjdD09PSdidScpLCAoZCkgPT4gZC5zaGFycGUpKVxuXG4gICAgICAgICAgICAgICAgbGV0IGF2Z3NoYXJwID0gW11cbiAgICAgICAgICAgICAgICBhbGxwcm9kLmZvckVhY2goayA9PiBhdmdzaGFycC5wdXNoKHtQcm9kdWN0OmssIFxuICAgICAgICAgICAgICAgICAgICBzaGFycGU6ZDMubWVhbihkYXRhX3llYXIuZmlsdGVyKGQgPT4gZC5Qcm9kdWN0PT09ayksIChkKSA9PiBkLnNoYXJwZSksXG4gICAgICAgICAgICAgICAgICAgIG1heGk6ZDMubWF4KGRhdGFfeWVhci5maWx0ZXIoZCA9PiBkLlByb2R1Y3Q9PT1rKSwgKGQpID0+IGQuc2hhcnBlKSxcbiAgICAgICAgICAgICAgICAgICAgbWluaTpkMy5taW4oZGF0YV95ZWFyLmZpbHRlcihkID0+IGQuUHJvZHVjdD09PWspLCAoZCkgPT4gZC5zaGFycGUpfSkpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYXZnc2hhcnApXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ICd5ZWFycycgIGFsaWduID0gJ2xlZnQnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGtleT1cInNsaWRlclwiIHR5cGU9J3JhbmdlJyBjbGFzcyA9ICdzbGlkZXInIGxpc3Q9XCJ0aWNrbWFya3NcIiBtaW49JzAnIG1heD0nMycgdmFsdWU9e3llYXJ9ICBzdGVwPScxJyBvbkNoYW5nZT17Y2hhbmdlSGFuZGxlclllYXJ9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGF0YWxpc3QgaWQ9XCJ0aWNrbWFya3NcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMFwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjJcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiM1wiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGF0YWxpc3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQga2V5PVwibW9udGhUZXh0XCIgY2xhc3M9J2xhYmVsaW5wdXQnIHR5cGU9XCJ0ZXh0XCIgdmFsdWU9e1lFQVJbeWVhcl19IHJlYWRPbmx5Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ICdtb250aCcgYWxpZ24gPSAnY2VudGVyJz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBrZXk9XCJzbGlkZXJcIiB0eXBlPSdyYW5nZScgbGlzdD1cInRpY2tcIiBjbGFzcyA9ICdzbGlkZXInICBtaW49JzAnIG1heD0nMTEnIHZhbHVlPXttb250aH0gc3RlcD0nMScgb25DaGFuZ2U9e2NoYW5nZUhhbmRsZXJNb250aH0vPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRhdGFsaXN0IGlkPVwidGlja1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMlwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIzXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjRcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiNVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI2XCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjdcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiOFwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI5XCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEwXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjExXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEyXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kYXRhbGlzdD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBrZXk9XCJtb250aFRleHRcIiBjbGFzcz0nbGFiZWxpbnB1dCcgdHlwZT1cInRleHRcIiB2YWx1ZT17TU9OVEhbbW9udGhdfSByZWFkT25seS8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyB3aWR0aD17V0lEVEh9IGhlaWdodD17SEVJR0hUfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8U2NhdHRlclBsb3Qgc2VsZWN0ZWQ9e3NlbGVjdGVkfSBzZXRzZWxlY3RlZD17c2V0c2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcD17dG9wfSBzZXR0b3A9e3NldHRvcH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdD17bGVmdH0gc2V0bGVmdD17c2V0bGVmdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTE9e2RhdGExfSBzZXRkYXRhMT17c2V0ZGF0YTF9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEyPXtkYXRhMn0gc2V0ZGF0YTI9e3NldGRhdGEyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMz17ZGF0YTN9IHNldGRhdGEzPXtzZXRkYXRhM31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YT17ZGF0YV9maW5hbH0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZG1vcmU9ezB9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8T3ZlclNjYXR0ZXJQbG90IHNlbGVjdGVkPXtzZWxlY3RlZH0gc2V0c2VsZWN0ZWQ9e3NldHNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3AxPXt0b3AxfSBzZXR0b3AxPXtzZXR0b3AxfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0MT17bGVmdDF9IHNldGxlZnQxPXtzZXRsZWZ0MX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTE9e2RhdGExfSBzZXRkYXRhMT17c2V0ZGF0YTF9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEyPXtkYXRhMn0gc2V0ZGF0YTI9e3NldGRhdGEyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMz17ZGF0YTN9IHNldGRhdGEzPXtzZXRkYXRhM31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YT17YXZnc2hhcnB9IGRhdGFfeWVhcj17ZGF0YV95ZWFyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRtb3JlPXstNTMwfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJhckNoYXJ0IHNlbGVjdGVkPXtzZWxlY3RlZH0gc2V0c2VsZWN0ZWQ9e3NldHNlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A9e3RvcH0gc2V0dG9wPXtzZXR0b3B9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ9e2xlZnR9IHNldGxlZnQ9e3NldGxlZnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGExPXtkYXRhMX0gc2V0ZGF0YTE9e3NldGRhdGExfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMj17ZGF0YTJ9IHNldGRhdGEyPXtzZXRkYXRhMn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTM9e2RhdGEzfSBzZXRkYXRhMz17c2V0ZGF0YTN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE9e2RhdGFfZmluYWx9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UHJpY2VDdXJ2ZSBzZWxlY3RlZD17c2VsZWN0ZWR9IHNldHNlbGVjdGVkPXtzZXRzZWxlY3RlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wPXt0b3B9IHNldHRvcD17c2V0dG9wfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0PXtsZWZ0fSBzZXRsZWZ0PXtzZXRsZWZ0fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhMT17ZGF0YTF9IHNldGRhdGExPXtzZXRkYXRhMX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTI9e2RhdGEyfSBzZXRkYXRhMj17c2V0ZGF0YTJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEzPXtkYXRhM30gc2V0ZGF0YTM9e3NldGRhdGEzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhPXtzdGF0aW9uWWVhckRhdGF9IGN1cnJlbnRtb250aD17bW5bbW9udGhdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRtb3JlPXs2MDB9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWYgPSAnaW5kZXguaHRtbCcgZmlsbCA9ICd3aGl0ZSc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzID0gJ2J1dHRvbic+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRleHQgc3R5bGU9e3sgdGV4dEFuY2hvcjonYm90dG9tJywgZm9udFNpemU6JzJlbSd9fSBmaWxsID0gJ3doaXRlJyB4ID0ge1wiMCVcIn0geSA9IHtcIjBcIn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhvbWUgUGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZyB3aWR0aCA9ICcxMDAlJyBoZWlnaHQgPSAnMSc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGluZSAgeDI9XCIxMDAlXCIgeTE9XCIxMDAlXCIgeTI9XCIxMDAlXCIgc3Ryb2tlID0gXCJ3aGl0ZVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICkgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKTtcblxuICAgICAgICAgICBSZWFjdERPTS5yZW5kZXIoIDxDaGFydHMgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JykpO1xuICAgICAgICAiXX0=</script></head>
<body style=" background: rgb(53, 50, 50);">
    <h1 style="color:rgb(231, 28, 28)">Zhengzhou Commodity Exchange (CZCE)</h1>
    <div id="root"><div><div><div class="years" align="left"><input type="range" class="slider" list="tickmarks" min="0" max="3" step="1" value="-1"><datalist id="tickmarks"><option value="0"></option><option value="1"></option><option value="2"></option><option value="3"></option></datalist><input class="labelinput" type="text" readonly="" value=""></div></div><div class="month" align="center"><input type="range" list="tick" class="slider" min="0" max="11" step="1" value="-1"><datalist id="tick"><option value="0"></option><option value="1"></option><option value="2"></option><option value="3"></option><option value="4"></option><option value="5"></option><option value="6"></option><option value="7"></option><option value="8"></option><option value="9"></option><option value="10"></option><option value="11"></option><option value="12"></option></datalist><input class="labelinput" type="text" readonly="" value=""></div><svg width="2600" height="800"><g transform="translate(630, 70)"><g><rect opacity="0" width="180" height="90" fill="lightblue"></rect><text transform="translate(null, null)" x="5" y="30" opacity="0" style="font-size: 12px;"></text><text transform="translate(null, null)" x="25" y="50" opacity="0" style="font-size: 12px;">Â· Trading Volume: 0</text><text transform="translate(null, null)" x="25" y="70" opacity="0" style="font-size: 12px;">Â· Sharpe Ratio: 0</text></g><g><line y2="300" stroke="white"></line><line x1="-600" y1="-50" x2="500" y2="-50" stroke="purple"></line><text transform="translate(5, -15)" y="20" fill="white" style="font-size: 14px;">Sharpe Ratio (yearly)</text></g><g><line y1="300" x2="470" y2="300" stroke="white"></line><text transform="translate(360, 270)" y="20" fill="white" style="font-size: 14px;">Trading Volume (1e3)</text></g></g><g transform="translate(100, 70)"><g><rect opacity="0" width="180" height="110" fill="lightblue"></rect><text transform="translate(null, null)" x="5" y="30" opacity="0" style="font-size: 12px;"></text><text transform="translate(null, null)" x="25" y="50" opacity="0" style="font-size: 12px;">Â· Max Sharpe Ratio: 0</text><text transform="translate(null, null)" x="25" y="70" opacity="0" style="font-size: 12px;">Â· Min Sharpe Ratio: 0</text><text transform="translate(null, null)" x="25" y="90" opacity="0" style="font-size: 12px;">Â· Avg Sharpe Ratio: 0</text></g><g><line y2="300" stroke="white"></line><line x1="-600" y1="-50" x2="500" y2="-50" stroke="purple"></line><text transform="translate(5, -15)" y="20" fill="white" style="font-size: 14px;">Sharpe Ratio (yearly)</text></g><g><line y1="300" x2="470" y2="300" stroke="white"></line></g></g><g transform="translate(630, 420)"><g></g><g><line y2="300" stroke="white"></line><text fill="white" transform="translate(5, -15)" y="20" style="font-size: 14px;">market volume (1e5)</text><g transform="translate(-10, 300)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">0</text></g><g transform="translate(-10, 270)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">10</text></g><g transform="translate(-10, 240)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">20</text></g><g transform="translate(-10, 210)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">30</text></g><g transform="translate(-10, 180)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">40</text></g><g transform="translate(-10, 150)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">50</text></g><g transform="translate(-10, 120)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">60</text></g><g transform="translate(-10, 90.00000000000001)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">70</text></g><g transform="translate(-10, 59.999999999999986)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">80</text></g><g transform="translate(-10, 29.999999999999993)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">90</text></g><g transform="translate(-10, 0)"><line x2="10" stroke="white"></line><text fill="white" style="text-anchor: end; font-size: 12px;">100</text></g></g><g transform="translate(470, 0)"><line y2="300" stroke="white"></line><text fill="white" x="-770" y="-380" style="text-anchor: middle; font-size: 16px;">Yearly Overview</text><text fill="white" x="-180" y="-380" style="text-anchor: middle; font-size: 16px;">Monthly Details</text><text transform="translate(-150, -15)" y="20" fill="white" style="font-size: 14px;">trading volume (1e3)</text><g transform="translate(0, 300)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">0</text></g><g transform="translate(0, 270)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">10</text></g><g transform="translate(0, 240)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">20</text></g><g transform="translate(0, 210)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">30</text></g><g transform="translate(0, 180)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">40</text></g><g transform="translate(0, 150)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">50</text></g><g transform="translate(0, 120)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">60</text></g><g transform="translate(0, 90.00000000000001)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">70</text></g><g transform="translate(0, 59.999999999999986)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">80</text></g><g transform="translate(0, 29.999999999999993)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">90</text></g><g transform="translate(0, 0)"><line x2="10" stroke="white"></line><text transform="translate(32, 0)" fill="white" style="text-anchor: end; font-size: 12px;">100</text></g></g><g><line y1="300" x2="470" y2="300" stroke="white"></line></g></g><div></div></svg><div><a href="index.html" fill="white"><button class="button"><text fill="white" x="0%" y="0" style="font-size: 2em;">Home Page</text></button></a><svg width="100%" height="1"><line x2="100%" y1="100%" y2="100%" stroke="white"></line></svg></div></div></div>
    <script type="text/babel">

        const margin = { top: 20, right: 30, bottom: 180, left: 80, gap: 50 };
        const csvUrl = 'https://raw.githubusercontent.com/jjl720/capstone/main/exchange_level_data.csv';
        
        function useData(csvPath){
            const [dataAll, setData] = React.useState(null);
            React.useEffect(() => {
                d3.csv(csvPath).then(data => {
                    data.forEach(d => {
                        d.sharpe = +d.Sharpe;
                        d.low = +d.low;
                        d.mean = +d.mean;
                        d.max = +d.max;
                        d.mv = +d.volume;
                        d.tv = +d.tradingvolume;
                    });
                    setData(data);
                });
            }, []);
            return dataAll;
        }

        function YAxis(props) {
            const {sys, height, type} = props;
            const ticks = sys.ticks(10);
            const judge = type == 'scatter';
            const judge2 = type == 'bar2';
            const judge3 = type == 'price';
            const color1 = d => d > 2 ? 'red' : 'rgb(28, 231, 197)';
            if (judge) {
                return <g>
                    <line y2={height} stroke ={`white`} />
                    <line x1={-600} y1 = {-50} x2= {500} y2={-50} stroke ={`purple`} />
                    <text style={{ font: 'sans-serif', fontSize: '14px'}}  
                            transform={`translate(5, -15)`} y={20} fill={'white'}>
                                {'Sharpe Ratio (yearly)'} 
                    </text>
                    {ticks.map( tickValue => {
                        return <g key={tickValue} transform={`translate(-10, ${sys(tickValue)})`}>
                                <line x2={10} stroke={"white"} />
                                <text style={{ textAnchor:'end', fontSize:'12px'}} fill={color1(tickValue)}>
                                {tickValue} 
                                </text>
                            </g> })}
                </g>
            }
            if (judge2) {
                
                return <g  transform={`translate(470, 0)`}>
                    <line y2={height} stroke ={`white`} />
                    <text style={{ font: 'sans-serif', textAnchor:'middle', fontSize:'16px'}} fill={'white'} x = {-770} y={-380}>
                                Yearly Overview
                    </text>
                    <text style={{ font: 'sans-serif', textAnchor:'middle', fontSize:'16px'}} fill={'white'} x = {-180} y={-380}>
                                Monthly Details
                    </text>
                    <text style={{ font: 'sans-serif', fontSize: '14px'}} 
                            transform={`translate(-150, -15)`} y={20} fill={'white'}>
                                {'trading volume (1e3)'} 
                    </text>
                    {ticks.map( tickValue => {
                        return <g key={tickValue} transform={`translate(0, ${sys(tickValue)})`}>
                                <line x2={10} stroke={"white"} />
                                <text style={{ textAnchor:'end', fontSize:'12px'}} transform={`translate(32, 0)`} fill={'white'}>
                                {tickValue} 
                                </text>
                            </g> })}
                </g>
            }
            if (judge3) {
                return <g>
                    <line y2={height} stroke ={`white`} />
                    <text style={{ font: 'sans-serif', fontSize: '14px'}}  
                            transform={`translate(5, -15)`} y={20} fill={'white'}>
                                {'Price Curve'} 
                    </text>
                    {ticks.map( tickValue => {
                        return <g key={tickValue} transform={`translate(-10, ${sys(tickValue)})`}>
                                <line x2={10} stroke={"white"} />
                                <text style={{ textAnchor:'end', fontSize:'12px'}} fill={'white'}>
                                {tickValue} 
                                </text>
                            </g> })}
                </g>
            }
            else {
                return <g>
                    <line y2={height} stroke ={`white`} />
                    <text style={{ font: 'sans-serif', fontSize: '14px'} }  fill={'white'}
                            transform={`translate(5, -15)`} y={20}>
                                {'market volume (1e5)'} 
                    </text>
                    {ticks.map( tickValue => {
                        return <g key={tickValue} transform={`translate(-10, ${sys(tickValue)})`}>
                                <line x2={10} stroke={"white"} />
                                <text style={{ textAnchor:'end', fontSize:'12px'}} fill={'white'}>
                                {tickValue} 
                                </text>
                            </g> })}
                </g>
            }
        }

        function XAxis(props) {
            const {data, sxs, width, height, type} = props;
            const judge = type == 'scatter';
            const judge2 = type == 'price';
            if (judge) {
                const ticks = sxs.ticks(10);
                return <g>
                    <line y1={height} x2={width} y2={height} stroke ={"white"} />
                    <text style={{ font: 'sans-serif', fontSize: '14px' }}  
                        transform={`translate(360, 270)`} y={20} fill={'white'}>
                                {'Trading Volume (1e3)'} 
                    </text>
                    {ticks.map( tickValue => {
                        return <g key={tickValue} transform={`translate(${sxs(tickValue)}, ${height})`}>
                                <line y2={5} stroke={"white"} />
                                <text style={{ textAnchor:'middle', fontSize:'12px', color:'white'}} fill={'white'} y={20}>
                                {tickValue} 
                                </text>
                            </g>
                        })}
                </g>
            }
            if (judge2) {
                return <g>
                    <line y1={height} x2={width} y2={height} stroke ={"white"} />
                    {data.map(d => {
                    return <text style={{ font: 'sans-serif', fontSize: '12px' }} fill={'white'} 
                        transform={`translate(${sxs(d.month)}, 293)`} y={20}>
                                {d.month} 
                    </text>
                    })}
                </g>
            }
            else{
                return <g>
                    <line y1={height} x2={width} y2={height} stroke ={"white"} />
                    {data.map(d => {
                    return <text style={{ font: 'sans-serif', fontSize: '12px' }}  fill={'white'}
                        transform={`translate(${sxs(d.Product)}, 293)`} y={20}>
                                {d.Product} 
                    </text>
                    })}
                </g>
            }
        }
        
        function Points(props) {
            console.log(props.selected)
            const {data, sxs, sys} = props;
            console.log(1);
            console.log(data);
            
            // console.log(data.filter(function(d){return d.month == 'May' & d.Product == 'York St'}))
            // function onMouseEnter(d){
            //     props.setselected(d)
            // }
            // function onMouseOut(){
            //     props.se
            // }

            const mouseOver = d =>{
                props.setselected(d.Product);
                props.settop(sys(d.sharpe));
                props.setleft(sxs(d.tv/1000));
                props.setdata1(d.sharpe);
                props.setdata2(d.tv);
            }
            const mouseOut = () =>{
                props.setselected(null);
                props.settop(null);
            }

            const color = d => d.tv === 0 ? "yellow" 
                    :d.Product === props.selected ? "steelblue" 
                    :d.sharpe > 2? 'red':'green';
            const radius = d => d.Product === props.selected ? 7 : 5;
            const opa = d => d === null ? 0 : 0.8;
            const opa2 = d => d === null ? 0 : 0.8;

            const selecteddata = data.filter(d => d.Product===props.selected)
            console.log('works?')
            console.log(selecteddata[0])
            if(selecteddata[0]){
                props.settop(sys(selecteddata[0].sharpe)-50);
                props.setleft(sxs(selecteddata[0].tv/1000)+20);}

            return <g>
                

                {data.map(d => {
                    return <circle key={d.Product} 
                                    cx={sxs(d.tv/1000)} 
                                    cy={sys(d.sharpe)} 
                                    r={radius(d)} 
                                    fill={color(d)} 
                                    stroke={'white'}
                                    onMouseOver={() => {mouseOver(d)}}
                                    style = {{transition:"1s"}}
                                    />;
                })}
                {data.filter(function(d){return d.Product == props.selected}).map(d => {
                    return <circle key={d.Product} 
                                    cx={sxs(d.tv/1000)} 
                                    cy={sys(d.sharpe)} 
                                    r={radius(d)} 
                                    fill={color(d)} 
                                    stroke={'white'}
                                    onMouseOut={mouseOut}
                                    style = {{transition:"100s"}}
                                    />;
                })}
                <rect  x = {props.left} y={props.top} opacity={opa(props.selected)}
                                width={180} height = {90} fill={'lightblue'}/>
                
                <text style={{ font: 'sans-serif', fontSize: '12px' }}  
                        transform={`translate(${props.left}, ${props.top})`} x={5} y={30}
                        opacity={opa2(props.selected)}>
                                {props.selected}  
                </text>
                <text style={{ font: 'sans-serif', fontSize: '12px' }}  
                        transform={`translate(${props.left}, ${props.top})`} x={25} y={50}
                        opacity={opa2(props.selected)}>
                                {"Â· Trading Volume: "}  
                                {Math.round(props.data2)}  
                </text>
                <text style={{ font: 'sans-serif', fontSize: '12px' }}  
                        transform={`translate(${props.left}, ${props.top})`} x={25} y={70}
                        opacity={opa2(props.selected)}>
                                {"Â· Sharpe Ratio: "}  
                                {Math.floor(props.data1 * 100) / 100}  
                </text>
            </g>
        }

        
        function OverPoints(props) {
            console.log(props.selected)
            const {data, sxs, sys} = props;
            console.log(1);
            console.log(data);
            
            // console.log(data.filter(function(d){return d.month == 'May' & d.Product == 'York St'}))
            // function onMouseEnter(d){
            //     props.setselected(d)
            // }
            // function onMouseOut(){
            //     props.se
            // }

            const mouseOver = d =>{
                props.setselected(d.Product);
                props.settop(sys(d.maxi));
                props.setleft(sxs(d.Product));
                props.setdata1(d.sharpe);
                props.setdata2(d.tv);
            }
            const mouseOut = () =>{
                props.setselected(null);
                props.settop(null);
            }

            const color = d => d.tv === 0 ? "yellow" 
                    :d.Product === props.selected ? "steelblue" 
                    :d.sharpe > 2? 'red':'green';
            const radius = d => d.Product === props.selected ? 10 : 5;
            const opa = d => d === null ? 0 : 0.8;
            const opa2 = d => d === null ? 0 : 0.8;

            const selecteddata = data.filter(d => d.Product===props.selected)
            console.log('works?')
            console.log(selecteddata[0])
            if(selecteddata[0]){
                props.settop(sys(selecteddata[0].maxi)-50);
                props.setleft(sxs(selecteddata[0].Product)+20);}
            
            const sharp = d => d? d.sharpe: 0;
            const maxi = d => d? d.maxi: 0;
            const mini = d => d? d.mini: 0;


            return <g>

                {data.map(d => {
                    return <circle key={d.Product} 
                                    cx={sxs(d.Product)} 
                                    cy={sys(d.sharpe)} 
                                    r={radius(d)} 
                                    fill={color(d)} 
                                    stroke={'white'}
                                    onMouseOver={() => {mouseOver(d)}}
                                    style = {{transition:"1s"}}
                                    />;
                })}
                {data.filter(function(d){return d.Product == props.selected}).map(d => {
                    return <circle key={d.Product} 
                                    cx={sxs(d.Product)} 
                                    cy={sys(d.sharpe)} 
                                    r={radius(d)} 
                                    fill={color(d)} 
                                    stroke={'white'}
                                    onMouseOut={mouseOut}
                                    style = {{transition:"100s"}}
                                    />;
                })}
                {data.filter(function(d){return d.Product == props.selected}).map(d => {
                    return <circle key={d.Product} 
                                    cx={sxs(d.Product)} 
                                    cy={sys(d.mini)} 
                                    r={radius(d)} 
                                    fill={color(d)} 
                                    stroke={'white'}
                                    onMouseOut={mouseOut}
                                    style = {{transition:"100s"}}
                                    />;
                })}
                {data.filter(function(d){return d.Product == props.selected}).map(d => {
                    return <circle key={d.Product} 
                                    cx={sxs(d.Product)} 
                                    cy={sys(d.maxi)} 
                                    r={radius(d)} 
                                    fill={color(d)} 
                                    stroke={'white'}
                                    onMouseOut={mouseOut}
                                    style = {{transition:"100s"}}
                                    />;
                })}
                <rect  x = {props.left} y={props.top} opacity={opa(props.selected)}
                                width={180} height = {110} fill={'lightblue'}/>
                
                <text style={{ font: 'sans-serif', fontSize: '12px' }}  
                        transform={`translate(${props.left}, ${props.top})`} x={5} y={30}
                        opacity={opa2(props.selected)}>
                                {props.selected}  
                </text>
                <text style={{ font: 'sans-serif', fontSize: '12px' }}  
                        transform={`translate(${props.left}, ${props.top})`} x={25} y={50}
                        opacity={opa2(props.selected)}>
                                {"Â· Max Sharpe Ratio: "}  
                                {Math.floor(maxi(selecteddata[0])*100)/100}  
                </text>
                <text style={{ font: 'sans-serif', fontSize: '12px' }}  
                        transform={`translate(${props.left}, ${props.top})`} x={25} y={70}
                        opacity={opa2(props.selected)}>
                                {"Â· Min Sharpe Ratio: "}  
                                {Math.floor(mini(selecteddata[0])*100)/100}  
                </text>
                <text style={{ font: 'sans-serif', fontSize: '12px' }}  
                        transform={`translate(${props.left}, ${props.top})`} x={25} y={90}
                        opacity={opa2(props.selected)}>
                                {"Â· Avg Sharpe Ratio: "}  
                                {Math.floor(sharp(selecteddata[0]) * 100) / 100}  
                </text>
            </g>
        }

        function ScatterPlot(props) {
            const data = props.data;
            if (!data) {return <pre>Loading...</pre>;};
            const WIDTH = 600;
            const HEIGHT = 800;
            const height = (HEIGHT - margin.top - margin.bottom)/2;
            const width = WIDTH - margin.left - margin.right - 20;
            const sxs = d3.scaleLinear()
                            .range([0, width])
                            .domain([0, d3.max(data, (d)=> d.tv/1000)])
                            .nice();
            console.log(d3.max(data, (d)=> d.sharpe))
            const sys = d3.scaleLinear()
                            .range([height, 0])
                            .domain([0, d3.max(data, (d)=> d.sharpe)])
                            .nice();
            
            return <g transform={`translate(${margin.left+550+props.addmore}, ${margin.top+50})`}>
                <Points data={props.data} sxs={sxs} sys={sys} color={'steelblue'}
                        selected={props.selected} setselected={props.setselected}
                        month={props.month}
                        top={props.top} settop={props.settop}
                        left={props.left} setleft={props.setleft}
                        data1={props.data1} setdata1={props.setdata1}
                        data2={props.data2} setdata2={props.setdata2}
                        data3={props.data3} setdata3={props.setdata3}/>
                <YAxis sys={sys} width={width} height={height} type={'scatter'}/>
                <XAxis sxs={sxs} width={width} height={height} type={'scatter'}/>
            </g>
        }

        function OverScatterPlot(props) {
            const data = props.data;
            if (!data) {return <pre>Loading...</pre>;};
            const WIDTH = 600;
            const HEIGHT = 800;
            const height = (HEIGHT - margin.top - margin.bottom)/2;
            const width = WIDTH - margin.left - margin.right - 20;
            const sxs = d3.scaleBand()
                            .range([0, width])
                            .domain(data.map(d => {return d.Product}));
            const sys = d3.scaleLinear()
                            .range([height, 0])
                            .domain([0, d3.max(data, (d)=> d.maxi)])
                            .nice();
            console.log('whats wrong')
            console.log(data)
            
            return <g transform={`translate(${margin.left+550+props.addmore}, ${margin.top+50})`}>
                <OverPoints data={props.data} sxs={sxs} sys={sys} color={'steelblue'}
                        selected={props.selected} setselected={props.setselected}
                        month={props.month}
                        top={props.top1} settop={props.settop1}
                        left={props.left1} setleft={props.setleft1}
                        data1={props.data1} setdata1={props.setdata1}
                        data2={props.data2} setdata2={props.setdata2}
                        data3={props.data3} setdata3={props.setdata3}/>
                <YAxis sys={sys} width={width} height={height} type={'scatter'}/>
                <XAxis data={props.data} sxs={sxs} width={width} height={height} type={'bar'}/>
            </g>
        }


        function Bars(props) {
            const [selected, setselected] = React.useState(null)
            const {data, sxs, sys, bxs, bys, by2} = props;
            
            // function onMouseEnter(d){
            //     props.setselected(d)
            // }
            // function onMouseOut(){
            //     props.se
            // }

            const mouseOver = d =>{
                props.setselected(d.Product);
                props.settop(sys(d.sharpe));
                props.setleft(sxs(d.tv/1000));
                props.setdata1(d.sharpe);
                props.setdata2(d.tv);
            }
            const mouseOut = () =>{
                props.setselected(null);
                props.settop(null);
            }

            const color = d => d.Product === props.selected ? "steelblue" : "yellow";
            const color2 = d => d.Product === props.selected ? "steelblue" : 
            d.mv/maxmv*100 > d.tv/maxtv*100 ? "green" : "red";

            const maxtv = d3.max(data, (d)=> d.tv)
            const maxmv = d3.max(data, (d)=> d.mv)
            return <g>
                {data.map(d => {
                    return <rect key={d.Product} x={bxs(d.Product)} y={bys(d.mv/maxmv*100)} 
                                    width={10} height={300-bys(d.mv/maxmv*100)}
                                    fill={color(d)} stroke={'white'}
                                    onMouseOver={() => {mouseOver(d)}}
                                    onMouseOut={mouseOut}/>
                })}
                {data.map(d => {
                    return <rect key={d.Product} x={bxs(d.Product)+10} y={by2(d.tv/maxtv*100)} 
                                    width={10} height={300-by2(d.tv/maxtv*100)}
                                    fill={color2(d)} stroke={'white'}
                                    onMouseOver={() => {mouseOver(d)}}
                                    onMouseOut={mouseOut}/>
                })}
            </g>
        }

        function BarChart(props) {
            const data = props.data;
            if (!data) {return <pre>Loading...</pre>;};
            const WIDTH = 600;
            const HEIGHT = 800;
            const height = (HEIGHT - margin.top - margin.bottom)/2;
            const width = WIDTH - margin.left - margin.right - 20;
            const sxs = d3.scaleLinear()
                            .range([0, width])
                            .domain([0, d3.max(data, (d)=> d.tv/1000)])
                            .nice();
            const sys = d3.scaleLinear()
                            .range([height, 0])
                            .domain([0, d3.max(data, (d)=> d.sharpe)])
                            .nice();
            const bxs = d3.scaleBand()
                            .range([0, width])
                            .domain(data.map(d => {return d.Product}));
            const bys = d3.scaleLinear()
                            .range([height, 0])
                            .domain([0,100])
                            .nice();
            const by2 = d3.scaleLinear()
                            .range([height, 0])
                            .domain([0, 100])
                            .nice();
            
            return <g transform={`translate(${margin.left+550}, ${margin.top+height+100})`}>
                <Bars data={props.data} sxs={sxs} sys={sys} bxs={bxs} bys={bys} by2={by2}
                selected={props.selected} setselected={props.setselected}
                top={props.top} settop={props.settop}
                        left={props.left} setleft={props.setleft}
                        data1={props.data1} setdata1={props.setdata1}
                        data2={props.data2} setdata2={props.setdata2}
                        data3={props.data3} setdata3={props.setdata3}
                month={props.month}/>
                <YAxis sys={bys} width={width} height={height} type={'bar'}/>
                <YAxis sys={by2} width={width} height={height} type={'bar2'}/>
                <XAxis data={props.data} sxs={bxs} width={width} height={height} type={'bar'}/>
            </g>
        }

        function SymmetricAreaChart(props) {
                const { offsetX, offsetY, data, height, width } = props;
                //the text needed is given in the following
                
                const xScale = d3.scaleBand()
                    .domain(['01','02','03','04','05','06','07','08','09','10','11','12'])
                    .range([0, width]);

                
                const yScale = d3.scaleLinear()
                                    .domain([0, d3.max([d3.max(data, d => d.low),d3.max(data, d => d.max)])])
                                    .range([height/2, 0])
                                    .nice();
                const p1 = d3.area()
                            .x(d => xScale(d.month))
                            .y0(height/2)
                            .y1(d => yScale(d.low))
                            .curve(d3.curveBasis)
                            (data);

                const p2 = d3.area()
                            .x(d => xScale(d.month))
                            .y0(height/2)
                            .y1(d => yScale(-d.max))
                            .curve(d3.curveBasis)
                            (data);

                const p3 = d3.area()
                            .x(d => xScale(d.month))
                            .y0(height/2)
                            .y1(d => yScale(d.mean))
                            .curve(d3.curveBasis)
                            (data);

                console.log('symm')
                console.log(data)

                return <g transform={`translate(${600}, ${0})`} >

                    <path d={p1} fill={'lightgreen'} stroke={'white'} />
                    <path d={p3} fill={'blue'} stroke={'white'} />
                    <path d={p2} fill={'red'} stroke={'white'} />
                    

                    {<line y2={height} stroke='white' transform={`translate(0, 0)`} /> }

                    {xScale.domain().map(tickValue =>
                            <g key={tickValue+'B'} transform={`translate(${xScale(tickValue)-10}, 30)`}>
                                <line y2={10} transform={`translate(10, ${height-22})`} stroke='white'/>
                                <text style={{textAnchor: 'start', fontSize:'12px' }} y={height} 
                                        transform={`rotate(0, 0, ${height+3})`}> {tickValue}
                                </text>
                            </g>
                        )}
                    
                    {yScale.ticks(2).map(tickValue => 
                        <g key={tickValue} transform={`translate(-10, ${yScale(tickValue)})`}>
                            <line x2={10} stroke='white' />
                            <text style={{ textAnchor:'end', fontSize:'10px' }} >
                                {tickValue}
                            </text>
                        </g>
                    )}

                    {yScale.ticks(2).reverse().map(tickValue => 
                        <g key={tickValue} transform={`translate(-10, ${height-yScale(tickValue)})`}>
                            <line x2={10} stroke='white' />
                            <text style={{ textAnchor:'end', fontSize:'10px' }} >
                                {tickValue}
                            </text>
                        </g>
                    )}
                    
                    {<line x1={600} y1={height/2} x2={1000} y2={height/2} stroke='white'/>}


                    <text style={{ textAnchor:'end', fontSize:'15px'}} transform={`translate(${width}, ${20})rotate(0)`}>
                            {"Start"}
                    </text>


                    <text style={{ textAnchor:'end', fontSize:'15px'}} transform={`translate(${width*2/3}, ${-10})rotate(0)`}>
                            {"Num. of riders over the year"}
                    </text>
                    
                    
                    <g transform={`translate(${offsetX}, ${offsetY+height/2})`}>    
                        <text style={{ textAnchor:'end', fontSize:'15px'}} transform={`translate(${width}, ${height/2-20})rotate(0)`}>
                            {"End"}
                    </text>
                    
                    </g>
                    </g>
            }
        
        function Pathdraw(props) {
            console.log(props.selected)
            const {data, sxs, sys} = props;
            console.log('really????');
            console.log(sxs('02'));
            
            // console.log(data.filter(function(d){return d.month == 'May' & d.Product == 'York St'}))
            // function onMouseEnter(d){
            //     props.setselected(d)
            // }
            // function onMouseOut(){
            //     props.se
            // }

            const mouseOver = d =>{
                props.setselected(d.Product);
                props.settop(sys(d.sharpe));
                props.setleft(sxs(d.tv/1000));
                props.setdata1(d.sharpe);
                props.setdata2(d.tv);
            }
            const mouseOut = () =>{
                props.setselected(null);
                props.settop(null);
            }

            const color = d => d.month === props.currentmonth ? 'steelblue' : 'black';
            const radius = d => d.month === props.currentmonth ? 5 : 3;
            const opa = d => d === null ? 0 : 0.6;
            const opa2 = d => d === null ? 0 : 0.8;

            const p1 = d3.area()
                .x(d => sxs(d.month)+10)
                .y0(300)
                .y1(d => sys(d.max))
                .curve(d3.curveBasis)
                (data);

            const p2 = d3.area()
                .x(d => sxs(d.month)+10)
                .y0(300)
                .y1(d => sys(d.low))
                .curve(d3.curveBasis)
                (data);

            const p3 = d3.area()
                .x(d => sxs(d.month)+10)
                .y0(300)
                .y1(d => sys(d.mean))
                .curve(d3.curveBasis)
                (data);

            return <g>
                <path d={p1} fill={'red'} stroke={'white'} />
                <path d={p3} fill={'lightgreen'} stroke={'white'} />
                <path d={p2} fill={'black'} stroke={'white'} />
                {data.map(d => {
                    return <circle cx={sxs(d.month)+10} 
                                    cy={sys(d.mean)} 
                                    r={radius(d)} 
                                    fill={color(d)} 
                                    stroke={'white'}
                                    onMouseOver={() => {mouseOver(d)}}
                                    style = {{transition:"1s"}}
                                    />;
                })}
            </g>
        }
     
        function PriceCurve(props) {
            const data = props.data;
            if (!data) {return <pre>Loading...</pre>;};
            const WIDTH = 600;
            const HEIGHT = 800;
            const height = (HEIGHT - margin.top - margin.bottom)/2;
            const width = WIDTH - margin.left - margin.right - 20;
            const sxs = d3.scaleBand()
                            .range([0, width])
                            .domain(data.map(d => {return d.month}));
            console.log('pricepriceprice')
            console.log(d3.max(data, (d)=> d.sharpe))
            const sys = d3.scaleLinear()
                            .range([height, 0])
                            .domain([0, d3.max(data, (d)=> d.max)])
                            .nice();
            
            if (props.selected == null){
                console.log('no more')
            return (
                <div> 
                </div>
            )   
            }else{
            return <g transform={`translate(${margin.left+20}, ${margin.top+height+100})`}>
                <Pathdraw data={props.data} sxs={sxs} sys={sys} color={'steelblue'}
                        selected={props.selected} setselected={props.setselected}
                        month={props.month}
                        top={props.top} settop={props.settop}
                        left={props.left} setleft={props.setleft}
                        data1={props.data1} setdata1={props.setdata1}
                        data2={props.data2} setdata2={props.setdata2}
                        data3={props.data3} setdata3={props.setdata3}
                        currentmonth={props.currentmonth}/>
                <YAxis sys={sys} width={width} height={height} type={'price'}/>
                <XAxis data={props.data} sxs={sxs} width={width} height={height} type={'price'}/>
            </g>
            }
        }

        function Tooltip(props) {
            const {d, stationYearData, left, top, height, width} = props;
            if (props.d == null){
                console.log('no more')
            return (
                <div> 
                </div>
            )   
            }else{
                console.log(stationYearData)
                console.log(d)
                console.log('here')
                return (
                    <g transform={`translate(${left}, ${top})`}>
                <text style={{ textAnchor:'start', fontSize:'15px'}}  transform={`translate(${0}, ${-5})rotate(0)`}>{d.Product} </text>
                <PriceCurve data={stationYearData}
                                        addmore={600}/>
            </g>
            )   
            }
        }
        
        const Charts = () => {
            const Home_page = () => { 
                return <div>
                    <a href = 'index.html' fill = 'white'>
                    <button class = 'button'>
                        <text style={{ textAnchor:'bottom', fontSize:'2em'}} fill = 'white' x = {"0%"} y = {"0"}>
                            Information Vizualization Project - Shanghai
                        </text>
                    </button>
                    </a>
                    <svg width = '100%' height = '1'>
                    <line  x2="100%" y1="100%" y2="100%" stroke = "white"/>
                    </svg>
                    </div>
            }
            var test = window.location.href;        
            console.log(test.split('=')[1].split('-')[1]);
            const mn = ['01','02','03','04','05','06','07','08','09','10','11','12']; 
            const YEAR = ['2017','2018','2019','2020'];
            const [selected, setselected] = React.useState(null)
            const [top, settop] = React.useState(null)
            const [left, setleft] = React.useState(null)
            const [top1, settop1] = React.useState(null)
            const [left1, setleft1] = React.useState(null)
            const [data1, setdata1] = React.useState(null)
            const [data2, setdata2] = React.useState(null)
            const [data3, setdata3] = React.useState(null)
            const [value, setvalue] = React.useState(4)
            const [month, setMonth] = React.useState(mn.indexOf(test.split('=')[1].split('-')[1]));
            const [year, setYear] = React.useState(YEAR.indexOf(test.split('=')[1].split('-')[0]));
            let monthlist = ['Jan', 'Feb', 'Mar', 'Apr', 
                            'May', 'Jun', 'Jul', 'Aug', 
                            'Sep','Oct','Nov','Dec'];
            const MONTH = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            // let slider = d3.select('#slider');
            // let slidertext = d3.select('#slidertext')
            // slider.on("input", function(){
            //     console.log(1)
            //     slidertext.attr('value', month[this.value-1]);
            // });
            const dataAll = useData(csvUrl);
            if (!dataAll) {
               return <pre>Loading...</pre>;
            };
            const WIDTH = 2600;
            const HEIGHT = 800;
            const innerHeight = HEIGHT - margin.top - margin.bottom;
            const innerWidth = WIDTH - margin.left - margin.right; 

            const data_year = dataAll.filter( d => {
            return d.year == YEAR[year] & d.Exchange == 'CZCE';
            });

            const data_final = data_year.filter( d => {
                const mn = ['01','02','03','04','05','06','07','08','09','10','11','12']; 
                return d.month == mn[month];
            });


            const changeHandlerMonth = (event) => {
                setMonth(event.target.value);
            };
            const changeHandlerYear = (event) => {
                setYear(event.target.value);
            };
            
            const selectedPoint = dataAll.filter(d => d.Product===selected)[0];

            
            console.log(mn[month]);
            console.log('another');

            const stationYearData = data_year.filter( d=> {
                return d.Product == selected;
            }); 
            let allprod = data_final.map(d => d.Product)
            console.log('what');
            
            console.log('try the average')
            console.log(d3.mean(data_year.filter(d => d.Product==='bu'), (d) => d.sharpe))

            let avgsharp = []
            allprod.forEach(k => avgsharp.push({Product:k, 
                sharpe:d3.mean(data_year.filter(d => d.Product===k), (d) => d.sharpe),
                maxi:d3.max(data_year.filter(d => d.Product===k), (d) => d.sharpe),
                mini:d3.min(data_year.filter(d => d.Product===k), (d) => d.sharpe)}))
            console.log(avgsharp)

            return (
                <div>
                    <div>
                    <div class= 'years'  align = 'left'>
                    <input key="slider" type='range' class = 'slider' list="tickmarks" min='0' max='3' value={year}  step='1' onChange={changeHandlerYear}/>
                        <datalist id="tickmarks">
                        <option value="0"></option>
                        <option value="1"></option>
                        <option value="2"></option>
                        <option value="3"></option>
                        </datalist>
                    <input key="monthText" class='labelinput' type="text" value={YEAR[year]} readOnly/>
                    </div>
                    </div>
                    
                    <div class= 'month' align = 'center'>
                    <input key="slider" type='range' list="tick" class = 'slider'  min='0' max='11' value={month} step='1' onChange={changeHandlerMonth}/>
                    <datalist id="tick">
                        <option value="0"></option>
                        <option value="1"></option>
                        <option value="2"></option>
                        <option value="3"></option>
                        <option value="4"></option>
                        <option value="5"></option>
                        <option value="6"></option>
                        <option value="7"></option>
                        <option value="8"></option>
                        <option value="9"></option>
                        <option value="10"></option>
                        <option value="11"></option>
                        <option value="12"></option>
                        </datalist>
                    <input key="monthText" class='labelinput' type="text" value={MONTH[month]} readOnly/>
                    </div>

                    <svg width={WIDTH} height={HEIGHT}>
                        <ScatterPlot selected={selected} setselected={setselected}
                                        top={top} settop={settop}
                                        left={left} setleft={setleft}
                                        data1={data1} setdata1={setdata1}
                                        data2={data2} setdata2={setdata2}
                                        data3={data3} setdata3={setdata3}
                                        data={data_final} 
                                        addmore={0}/>
                        <OverScatterPlot selected={selected} setselected={setselected}
                                        top1={top1} settop1={settop1}
                                        left1={left1} setleft1={setleft1}
                                        data1={data1} setdata1={setdata1}
                                        data2={data2} setdata2={setdata2}
                                        data3={data3} setdata3={setdata3}
                                        data={avgsharp} data_year={data_year}
                                        addmore={-530}/>
                        <BarChart selected={selected} setselected={setselected}
                                        top={top} settop={settop}
                                        left={left} setleft={setleft}
                                        data1={data1} setdata1={setdata1}
                                        data2={data2} setdata2={setdata2}
                                        data3={data3} setdata3={setdata3}
                                        data={data_final}/>
                        <PriceCurve selected={selected} setselected={setselected}
                                        top={top} settop={settop}
                                        left={left} setleft={setleft}
                                        data1={data1} setdata1={setdata1}
                                        data2={data2} setdata2={setdata2}
                                        data3={data3} setdata3={setdata3}
                                        data={stationYearData} currentmonth={mn[month]}
                                        addmore={600}/>
                    </svg>
                    <div>
                    <a href = 'index.html' fill = 'white'>
                    <button class = 'button'>
                        <text style={{ textAnchor:'bottom', fontSize:'2em'}} fill = 'white' x = {"0%"} y = {"0"}>
                            Home Page
                        </text>
                    </button>
                    </a>
                    <svg width = '100%' height = '1'>
                    <line  x2="100%" y1="100%" y2="100%" stroke = "white"/>
                    </svg>
                    </div>
                </div>
            )   
        }
        const rootElement = document.getElementById('root');

       ReactDOM.render( <Charts />, document.getElementById('root'));
    </script> 

</body></html>
